<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.jpg?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="原文链接：Async/await proposal  介绍现代Swift开发会涉及到大量的异步编程，一般来说我们通过回调来完成，但是回调的api非常难以使用。当代码涉及了非常多的异步操作，还要进行错误处理，并且回调之间互相依赖时，这会带来非常大的麻烦。本提议描述了对语言的拓展，让这一切变得更自然更不易出错。 我们打算为Swift引入协程的模型。函数可以是异步的，这让程序员们能够使用正常的控制流来">
<meta property="og:type" content="article">
<meta property="og:title" content="Async&#x2F;await">
<meta property="og:url" content="http://yoursite.com/2020/11/09/asyncawait/index.html">
<meta property="og:site_name" content="Ballad">
<meta property="og:description" content="原文链接：Async/await proposal  介绍现代Swift开发会涉及到大量的异步编程，一般来说我们通过回调来完成，但是回调的api非常难以使用。当代码涉及了非常多的异步操作，还要进行错误处理，并且回调之间互相依赖时，这会带来非常大的麻烦。本提议描述了对语言的拓展，让这一切变得更自然更不易出错。 我们打算为Swift引入协程的模型。函数可以是异步的，这让程序员们能够使用正常的控制流来">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-11-08T16:18:51.177Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Async&#x2F;await">
<meta name="twitter:description" content="原文链接：Async/await proposal  介绍现代Swift开发会涉及到大量的异步编程，一般来说我们通过回调来完成，但是回调的api非常难以使用。当代码涉及了非常多的异步操作，还要进行错误处理，并且回调之间互相依赖时，这会带来非常大的麻烦。本提议描述了对语言的拓展，让这一切变得更自然更不易出错。 我们打算为Swift引入协程的模型。函数可以是异步的，这让程序员们能够使用正常的控制流来">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/11/09/asyncawait/">





  <title>Async/await | Ballad</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ballad</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-snippets">
          <a href="/develop/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br>
            
            片段
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/09/asyncawait/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Async/await</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-09T00:15:17+08:00">
                2020-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>原文链接：<a href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md" target="_blank" rel="noopener">Async/await proposal</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现代Swift开发会涉及到大量的异步编程，一般来说我们通过回调来完成，但是回调的api非常难以使用。当代码涉及了非常多的异步操作，还要进行错误处理，并且回调之间互相依赖时，这会带来非常大的麻烦。本提议描述了对语言的拓展，让这一切变得更自然更不易出错。</p>
<p>我们打算为Swift引入协程的模型。函数可以是异步的，这让程序员们能够使用正常的控制流来编写包含异步操作的复杂逻辑。编译器负责将异步函数转换为一组适当的闭包和状态机。</p>
<p>这个提议定义了异步函数的语义，但是不提供并发行，并发性相关建议会在另外一个提议中详细阐述。并发性的提议会将异步函数与并发执行的任务相关联，并提供创建、查询和取消任务的api。</p>
<p>本提议从Chris Lattner和Joe Groff之前写的一个提议中得到了很多启发。提议本身源于<a href="https://gist.github.com/oleganza/7342ed829bddd86f740a" target="_blank" rel="noopener">Oleg Andreev的提议</a>。显然，很多内容都经过了重写，细节也发生了改变，但是核心思想仍然是一致的。</p>
<h2 id="动机：回调不是最优解"><a href="#动机：回调不是最优解" class="headerlink" title="动机：回调不是最优解"></a>动机：回调不是最优解</h2><p>在异步编程中使用显式回调（也称为完成回调）有许多问题，我们将在下面探讨这些问题。提议通过在语言中引入异步函数来解决这些问题。异步函数允许将异步代码写成单行的形式。它们还能实现直接推断代码的执行模式，从而让回调更有效地运行。</p>
<h3 id="问题一：回调地狱"><a href="#问题一：回调地狱" class="headerlink" title="问题一：回调地狱"></a>问题一：回调地狱</h3><p>一系列简单的异步操作通常需要深度嵌套的闭包。下面是一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1</span><span class="params">(completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource <span class="keyword">in</span></span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource <span class="keyword">in</span></span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp <span class="keyword">in</span></span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData1 &#123; image <span class="keyword">in</span></span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种回调地狱使得阅读和跟踪代码运行的位置变得非常困难。此外，使用一堆闭包会导致许多二阶效应，我们将在下文中讨论。</p>
<h3 id="问题二：错误处理"><a href="#问题二：错误处理" class="headerlink" title="问题二：错误处理"></a>问题二：错误处理</h3><p>回调使错误处理变得非常困难和冗长。Swift 2为同步代码引入了一个错误处理模型，但是基于回调的接口并没有从中得到任何好处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> imageTmp = imageTmp <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> imageResult = imageResult <span class="keyword">else</span> &#123;</span><br><span class="line">                        completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; image, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123;</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Result</code>的加入让Swift的api在错误处理这一块得到了提升。异步api也是<code>Result</code>的引入的一个重要动机：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(Result&lt;Image&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResourceResult <span class="keyword">in</span></span><br><span class="line">        dataResourceResult.<span class="built_in">map</span> &#123; dataResource <span class="keyword">in</span></span><br><span class="line">            loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResourceResult <span class="keyword">in</span></span><br><span class="line">                imageResultResult.<span class="built_in">map</span> &#123; imageResource <span class="keyword">in</span></span><br><span class="line">                    decodeImage(dataResource, imageResource) &#123; imageTmpResult <span class="keyword">in</span></span><br><span class="line">                        imageTmpResult.<span class="built_in">map</span> &#123; imageTmp <span class="keyword">in</span> </span><br><span class="line">                            dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                                completionBlock(imageResult)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> image):</span><br><span class="line">        display(image)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用<code>Result</code>时，我们更容易正确地处理错误，从而缩短代码。但是，回调地狱问题仍然存在。</p>
<h3 id="问题三：条件执行很困难并且容易出错"><a href="#问题三：条件执行很困难并且容易出错" class="headerlink" title="问题三：条件执行很困难并且容易出错"></a>问题三：条件执行很困难并且容易出错</h3><p>通过执行异步函数是一件非常痛苦的事情。举个例子，假设我们需要在获得图像后对其进行<code>swizzle</code>。我们可能不得不在<code>swizzle</code>之前执行一些异步代码。也许构造这个函数的最好的函数是把swizzle的代码组织成一个逃逸闭包，并在异步函数的完成回调中被捕获，像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData3</span><span class="params">(recipient: Person, completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> swizzle: (contents: image) -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">      <span class="comment">// ... continuation closure that calls completionBlock eventually</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        swizzle(recipient.profilePicture)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeImage &#123; image <span class="keyword">in</span></span><br><span class="line">            swizzle(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种模式颠倒了一个函数自上而下的组织方式：在函数的后半部分执行的代码出现在了前半部分。除了重新构造整个函数之外，我们现在还必须仔细考虑闭包的捕获，因为这个闭包是在完成回调中使用的。随着条件执行的异步函数数量的增加，问题会进一步恶化，从而产生实质上的回调地狱。</p>
<h3 id="问题四：实在太容易出错了"><a href="#问题四：实在太容易出错了" class="headerlink" title="问题四：实在太容易出错了"></a>问题四：实在太容易出错了</h3><p>只需简单地返回，不调用正确的完成回调，就可以很容易地提前退出异步操作。当你搞忘了的时候，这个问题是很难调试的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData4</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你记得调用回调时，你仍然可能会忘记在调用回调之后返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData5</span><span class="params">(recipient:Person, completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> image = recipient.profilePicture &#123;</span><br><span class="line">            completionBlock(image) <span class="comment">// &lt;- forgot to return after calling the block</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是，<code>guard</code>语法在某种程度上让你避免了忘记返回的情况，但它并不能给你永远的保护。</p>
<h3 id="问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"><a href="#问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了" class="headerlink" title="问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"></a>问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了</h3><p>虽然很难量化，但笔者认为，使用回调的尴尬导致许多api被定义为同步行为，甚至在它们可能阻塞的时候。这可能会导致UI应用程序的性能和响应性问题，例如loading光标。它还会导致一些api无法在异步对规模至关重要的情况下使用，比如在服务器上。</p>
<h2 id="解决方案：async-await"><a href="#解决方案：async-await" class="headerlink" title="解决方案：async/await"></a>解决方案：async/await</h2><p>异步函数——通常称为<code>async/await</code>——允许异步代码像单行的同步代码一样编写。通过允许程序员充分使用同步代码可用的相同语言结构，它可以立即解决上面描述的许多问题。使用<code>async/await</code>也自然地保留了代码的语义结构，提供了至少三个对语言的改进所必需的信息：</p>
<ol>
<li>更好的异步代码性能</li>
<li>更好的工具，在调试、剖析和探索代码时提供更一致的体验</li>
<li>为将来的并发特性（如任务的优先级和取消）奠定基础。</li>
</ol>
<p>我们使用前面的例子演示一下<code>async/await</code>如何大大简化异步代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadWebResource</span><span class="params">(<span class="number">_</span> path: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Resource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(<span class="number">_</span> r1: Resource, <span class="number">_</span> r2: Resource)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dewarpAndCleanupImage</span><span class="params">(<span class="number">_</span> i : Image)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = await <span class="keyword">try</span> loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = await <span class="keyword">try</span> loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageTmp      = await <span class="keyword">try</span> decodeImage(dataResource, imageResource)</span><br><span class="line">  <span class="keyword">let</span> imageResult   = await <span class="keyword">try</span> dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多关于<code>async/await</code>的实现描述都是一个通用的机制：将函数切割为多个部分的编译器传递。这在抽象的底层层次上理解机器是如何运行的是很重要的，但在更高层次上，我们希望您忽略它。相反，可以将异步函数看作具有放弃线程的特殊能力的普通函数。异步函数通常不会直接使用这种能力；相反，它们只是进行方法调用，有时这些调用将要求它们放弃线程并等待某些事情发生。当该操作完成时，函数将继续执行。</p>
<p>这与同步函数有很强的相似性。同步函数的调用会在调用完成前等待，在调用完成后返回。一旦调用完成，控制流会回到调用时的位置并从它停止的地方继续。异步函数也是如此：它可以像往常一样调用；当进行调用时，它通常会立即等待调用的完成。一旦调用完成，控制权就返回到函数，恢复到原来的位置。唯一的区别是同步函数可以充分利用部分它们的线程及其堆栈，而异步函数可以完全放弃堆栈而使用它们自己单独的存储区域。异步函数的这种额外功能有一些实现成本，但我们可以通过围绕它进行整体设计来降低成本。</p>
<p>因为异步函数必须能够放弃自己的线程，而同步函数不知道如何放弃一个线程，所以同步函数通常不能调用异步函数：异步函数只能放弃它占领的线程的一部分。如果进行一下这样的尝试，同步函数中调用一个异步函数，同步函数需要等待异步函数的返回。一般来说，实现这一功能的唯一方式是阻塞整个线程，直到异步函数恢复并完成，那这将完全违背异步函数的目的，并会造成恶劣的系统影响。</p>
<p>相反，异步函数既可以调用同步函数也可以调用异步函数。当然，在调用同步函数时，它不能放弃线程。实际上，异步函数不会直接放弃线程；它们只有在到达所谓的挂起点时才会放弃线程，挂起点就是<code>await</code>。挂起点可以直接发生在一个函数中，也可以发生在该函数调用的另一个异步函数中，但在任何一种情况下，该函数及其所有异步调用者都会同时放弃线程。(在实践中，异步函数在编译时不依赖于异步调用期间的线程，因此只有最内层的函数需要做一些额外的工作。)</p>
<p>当控制流返回到一个异步函数时，它会准确地恢复到原来的位置。这并不一定意味着它将在与之前完全相同的线程上运行，因为语言层不能保证在挂起之后会这样做。在这种设计中，线程主要是一种实现机制，而不是预期的并发接口的一部分。然而，许多异步函数并不仅仅是异步的：它们还与特定的<code>actor</code>相关联，并且它们总是作为<code>actor</code>的一部分运行。Swift保证这些函数实际上将返回到其<code>actor</code>以完成执行。因此，直接使用线程进行状态隔离的库——例如，通过创建自己的线程并在线程上顺序调度任务——通常应该在Swift中将这些线程转化为<code>actor</code>，以在Swift中保证正常运行。</p>
<h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>挂起点是执行异步函数时放弃线程的点。挂起点总是与函数中一些确定性的、语法上明确的事件相关联；从函数的角度来看，它们不会是被隐藏的或异步的。详细的语言设计将把几个不同的操作描述为挂起点，但最重要的一个操作是对与不同上下文的异步函数的调用。</p>
<p>重要的是，挂起点只与显式操作相关联。事实上，这个提议要求将可能暂停的调用封装在一个<code>await</code>表达式中，这是非常重要的。这沿袭了Swift使用<code>try</code>表达式来处理可能引发错误的函数调用的先例。标记挂起点特别重要，因为挂起中断了原子性。例如，如果一个异步函数在一个受串行队列保护的上下文中运行，达到一个挂起点意味着其他代码可以交错在同一串行队列上。原子性的重要性可以体现在一个经典但有点老旧的例子：如果存款被存入一个帐户，但操作在处理匹配的取款之前暂停，那么它将创建一个时间窗口，在该窗口中可以重复使用这些资金。对许多Swift程序员来说，一个更贴切的例子是UI线程：挂起点是UI可以显示给用户的点，因此程序构建部分UI然后挂起的风险是呈现一个卡住了的、部分构造的UI。(注意，代码中也使用显式回调显式地调用挂起点：挂起发生在外部函数返回点和回调开始运行点之间。)我们要求所有的挂起点都被标记，这使得程序员可以安全地假定没有挂起点的地方将按照原子方式运行，并且更容易识别出有问题的非原子模式。</p>
<p>由于挂起点只能出现在异步函数中被显式标记的点上，因此长时间的计算仍然会阻塞线程。当调用一个只做大量工作的同步函数时，或者遇到直接在异步函数中编写的特别密集的计算循环时，可能会发生这种情况。在任何一种情况下，线程都不能在这些计算运行时交错代码，这通常是正确的选择，但也可能成为延展性问题。需要进行密集计算的异步程序通常应该在单独的上下文中运行。当这不可行的时候，将会有一些工具来人为地挂起并允许其他操作进行交叉。</p>
<p>异步函数应该避免调用那些实际上会阻塞线程的函数，特别是当它们阻塞线程的目的是等待哪些不能保证当前正在运行的工作完成的时候。例如，获取互斥锁的行为只能被阻塞，直到当前运行的线程放弃该互斥锁；这有时是可以接受的，但必须谨慎使用，以避免引入死锁或人为的延展性问题。相反，等待一个条件变量可能会阻塞，直到某个工作被调度，并通知该变量；这种模式与推荐的方式是背道而驰的。需要做一些工作来让程序避免这些缺陷。</p>
<p>当异步函数在另一个上下文中等待操作时，此设计目前没有提供阻止当前上下文并切换的函数。这种省略是有意为之的：为了防止出现死锁。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>对<code>async</code>函数的调用看上去和实际运行上都很像对同步函数的调用。调用一个<code>async</code>函数的语义是：</p>
<ul>
<li>参数是使用普通规则计算的，包括对任何inout参数的初始访问。</li>
<li>被调用者的执行者是确定的。该提议没有说明确定执行者的规则；参见关于<code>actor</code>的补充建议。</li>
<li>如果被调用者的执行者与调用者的执行者不同，则会发生挂起，在被调用者中恢复执行的部分任务会安排到被调用者的执行程序上。</li>
<li>被调用者在其执行者上使用给定的参数执行。</li>
<li>在返回期间，如果被调用者的执行者与调用者的执行者不同，则会发生挂起，并且在调用者中恢复执行的部分任务会安排到调用者的执行程序中。</li>
<li>最后，调用者在它的执行者上继续执行。如果被调用方正常返回，则调用表达式的结果为函数返回的值；否则，表达式将抛出被调用方抛出的错误。</li>
</ul>
<p>从调用方的角度来看，异步调用的行为类似于同步调用，除了它们可能在不同的执行者上执行，需要任务被暂时挂起。还要注意的是，由于调用上的挂起，inout访问的持续时间可能要长得多，因此inout对共享的可变状态的引用没有充分隔离，更有可能产生动态排他性冲突。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>函数类型可以显式标记为<code>async</code>，表示函数是异步的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collect</span><span class="params">(function: <span class="params">()</span></span></span> async -&gt; <span class="type">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>函数或初始化声明也可以显式声明为<code>async</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(hiringFrom: <span class="type">College</span>) async <span class="keyword">throws</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">raiseHand</span><span class="params">()</span></span> async -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对声明为<code>async</code>的函数的引用以及初始化方法均是<code>async</code>函数类型 。如果引用是对实例方法的柯里化的静态引用，则内层的函数类型是异步的，这与此类引用的规则是一致的。</p>
<p>一些特殊的函数，比如<code>deinit</code>以及存储访问器不能标为<code>async</code>。</p>
<blockquote>
<p>原理阐述：只有getter的属性可能是<code>async</code>的。但是，同样具有异步setter的属性意味着能够将属性作为inout传递并深入到该属性本身，这取决于setter是否有效地是一个同步操作。禁止异步属性比只允许get的异步属性更简单。</p>
</blockquote>
<p>如果一个函数既是<code>async</code>又是<code>throws</code>，那么在声明时，<code>async</code>必须在<code>throws</code>之前。同样的规则也被应用在<code>async</code>和<code>rethrows</code>上。</p>
<blockquote>
<p>原理阐述：这种顺序限制没有很特别的理由，但它没有坏处，而且它消除了对风格的潜在争论。</p>
</blockquote>
<h3 id="异步函数类型"><a href="#异步函数类型" class="headerlink" title="异步函数类型"></a>异步函数类型</h3><p>异步函数类型不同于同步函数类型。不存在从同步函数类型到相应异步函数类型的隐式转换。但是，将非抛出异步函数类型的值隐式转换为相应的抛出异步函数类型是允许的。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctionTypes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> syncNonThrowing: () -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> syncThrowing: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> asyncNonThrowing: () async -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> asyncThrowing: () async <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">  </span><br><span class="line">  mutable <span class="function"><span class="keyword">func</span> <span class="title">demonstrateConversions</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Okay to convert to throwing form</span></span><br><span class="line">    syncThrowing = syncNonThrowing</span><br><span class="line">    asyncThrowing = asyncNonThrowing</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error to convert between asynchronous and synchronous</span></span><br><span class="line">    asyncNonThrowing = syncNonThrowing <span class="comment">// error</span></span><br><span class="line">    syncNonThrowing = asyncNonThrowing <span class="comment">// error</span></span><br><span class="line">    asyncThrowing = syncThrowing       <span class="comment">// error</span></span><br><span class="line">    syncThrowing = asyncThrowing       <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以手动创建一个调用同步函数的<code>async</code>闭包，因此缺少隐式转换不会有表达能力上的影响。有关定义<code>async</code>闭包的语法，请参阅“闭包”一节。</p>
<blockquote>
<p>原理阐述：我们不建议使用从同步函数到异步函数的隐式转换，因为这会使类型检查复杂化，特别是在存在同一函数的同步和异步重载的情况。有关更多信息，请参阅“重载和重载解析”一节。</p>
</blockquote>
<h3 id="Await表达式"><a href="#Await表达式" class="headerlink" title="Await表达式"></a>Await表达式</h3><p>对<code>async</code>函数类型的值的调用（包括对<code>async</code>函数的直接调用）带来了一个挂起点。任何挂起点都必须发生在一个异步的上下文中（例如，一个<code>async</code>函数）。而且，它必须出现在<code>await</code>表达式的操作中。</p>
<p>看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func redirectURL(for url: URL) async -&gt; URL &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// func dataTask(with: URL) async throws -&gt; URLSessionDataTask &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newURL = await server.redirectURL(<span class="keyword">for</span>: url)</span><br><span class="line"><span class="keyword">let</span> (data, response) = await <span class="keyword">try</span> session.dataTask(with: newURL)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，一个任务的挂起可能发生在<code>redirectURL(for:)</code>和<code>dataTask(with:)</code>中，因为它们都是异步函数。因此，两个调用表达式都必须包含在<code>await</code>表达式中，因为它们都包含了挂起点。尽管在<code>await</code>的操作中允许有多个挂起点，但<code>await</code>表达式的操作必须至少包含一个挂起点。例如，我们可以使用一个<code>await</code>来覆盖两个挂起点来重写上面的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (data, response) = await <span class="keyword">try</span> session.dataTask(with: server.redirectURL(<span class="keyword">for</span>: url))</span><br></pre></td></tr></table></figure></p>
<p><code>await</code>没有其他的语义；像<code>try</code>一样，它只是标记正在进行异步调用。<code>await</code>表达式的类型是它的操作者的类型，返回结果是其操作者的结果。</p>
<blockquote>
<p>原理阐述：重要的是，异步调用必须在函数内被清晰地识别，因为它们引入了挂起点，这会破坏操作的原子性。挂起点可能是调用所固有的（因为异步调用必须在不同的执行者上执行），或者仅仅是被调用者实现的一部分，但是在任何一种情况下，它在语义上都是重要的，程序员需要有正确的认识。<code>await</code>表达式也是异步代码的指示符，它与闭包中的推断相关联；更多信息请参见“闭包”一节。</p>
</blockquote>
<p>挂起点不能出现在非<code>async</code>函数类型的自动闭包中。</p>
<p>挂起点不能出现在<code>defer</code>的block中。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个闭包可以具有<code>async</code>的函数类型。这样的闭包可以明确地标记为<code>async</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; () async -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> await getInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果匿名闭包包含一个<code>await</code>表达式，则推断它具有<code>async</code>函数类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closure = &#123; await getInt() &#125; <span class="comment">// implicitly async</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure2 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>     <span class="comment">// implicitly async</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> await getInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对闭包的<code>async</code>推断不会延伸到它的封闭性、嵌套函数或闭包，因为这些上下文不论异步或同步都是可分离的。例如，只有<code>closure6</code>在这种情况下被推断为<code>async</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func getInt() async -&gt; Int &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure5 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>       <span class="comment">// not 'async'</span></span><br><span class="line">  <span class="keyword">let</span> closure6 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>     <span class="comment">// implicitly async</span></span><br><span class="line">    <span class="keyword">if</span> randomBool() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"there"</span>)</span><br><span class="line">      <span class="keyword">return</span> await getInt()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> closure7 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="number">7</span> &#125;  <span class="comment">// not 'async'</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载和重载解析"><a href="#重载和重载解析" class="headerlink" title="重载和重载解析"></a>重载和重载解析</h3><p>现有的包含一个操作同步和异步入口的Swift程序，可能会为每个操作使用两种命名相似的方法来设计：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(completionHandler: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在调用方看来上，通过是否传入回调可以清楚地了解正在调用哪个方法。然而，随着第二种方法的api直接映射到一个<code>async</code>函数，这两种方法现在非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> async -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">doSomething() <span class="comment">// synchronous or asynchronous?</span></span><br></pre></td></tr></table></figure>
<p>如果我们用<code>throws</code>替换<code>async</code>，声明上面的两个方法会产生一个“invalid redeclaration”的编译错误。但是，我们建议允许<code>async</code>函数重载非<code>async</code>函数，因此上面的代码是没问题的。这允许现有的Swift程序发展现有同步函数的<code>async</code>版本，而不会产生虚假的重命名。</p>
<p>重载<code>async</code>和非<code>async</code>函数的能力与重载解析规则相对应，根据调用的上下文选择适当的函数。对于一个调用，重载解析倾向于在同步上下文中使用非<code>async</code>函数，因为这样的上下文中不能包含对异步函数的调用。此外，重载解析倾向于在异步上下文中使用<code>async</code>函数，因为当有替代方法时，这样的上下文应该避免同步、阻塞api。当重载解析选择一个<code>async</code>函数时，该调用必须发生在一个await表达式中。</p>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>除非函数本身是<code>async</code>，否则函数不能使用<code>async</code>函数类型的自动闭包参数。例如，下面的声明格式是不正确的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: async autoclosure in a function that is not itself 'async'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeArgumentLater</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: @escaping @autoclosure <span class="params">()</span></span></span> async -&gt; <span class="type">T</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这一限制的存在有几个原因。考虑下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func getIntSlowly() async -&gt; Int &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  computeArgumentLater(await getIntSlowly())</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，<code>await</code>表达式告诉程序员调用<code>computeArgumentLater(_:)</code>会有一个挂起点，实际上并不是这样：挂起点位于被<code>computeArgumentLater(_:)</code>使用和传递的自动闭包内部。这导致了一些问题。首先，<code>await</code>出现在调用上这一事实意味着我们将推断闭包具有<code>async</code>函数类型，然而这也是不正确的：闭包中的所有代码都是同步的。其次，因为一个<code>await</code>的操作只需要包含一个暂停点在它的某个位置，一个等效的重写的调用应该是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await computeArgumentLater(getIntSlowly())</span><br></pre></td></tr></table></figure>
<p>但是，因为参数是一个自动闭包，所以这种重写没有保留它语义。因此，对<code>async</code>自动闭包参数的限制确保<code>async</code>自动闭包参数只能在异步上下文中使用，从而避免了这些问题。</p>
<h2 id="源码兼容性"><a href="#源码兼容性" class="headerlink" title="源码兼容性"></a>源码兼容性</h2><p>这个提议基本上只是一些新的添加：现有代码不会使用任何新特性（例如，不创建<code>async</code>函数或闭包），因此不会受到影响。但是，它引入了两个新的上下文关键字：<code>async</code>和<code>await</code>。</p>
<p>语法中<code>async</code>的用法位置（函数声明、函数类型和作为<code>let</code>的前缀）允许我们将async作为上下文关键字处理，而不会破坏源代码的兼容性。用户定义的<code>async</code>不能出现在代码的相应语法位置中。</p>
<p><code>await</code> 这个上下文相关的关键字有一些问题，因为它发生在表达式中。例如，我们可以在Swift中定义一个功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">await</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; x + y &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = await(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这是一段格式良好的代码，它是对<code>await</code>函数的调用。根据这个提议，这段代码变成了一个带有子表达式(1,2)的<code>await</code>表达式，这对于现有的Swift程序来说是一个编译时错误，因为等待只能在异步上下文中使用，而且现有的Swift程序没有这样的上下文。这样的函数看起来并不常见，所以我们认为这是引入<code>async/await</code>时可以接受的源码破坏。</p>
<h2 id="对ABI稳定性的影响"><a href="#对ABI稳定性的影响" class="headerlink" title="对ABI稳定性的影响"></a>对ABI稳定性的影响</h2><p>无</p>
<h2 id="对API弹性的影响"><a href="#对API弹性的影响" class="headerlink" title="对API弹性的影响"></a>对API弹性的影响</h2><p>无</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/07/swiftconcurrencyroadmap/" rel="next" title="Swift并发路线图">
                <i class="fa fa-chevron-left"></i> Swift并发路线图
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Junjie Lu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/junjielu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/lujunjie1008" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动机：回调不是最优解"><span class="nav-number">2.</span> <span class="nav-text">动机：回调不是最优解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题一：回调地狱"><span class="nav-number">2.1.</span> <span class="nav-text">问题一：回调地狱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题二：错误处理"><span class="nav-number">2.2.</span> <span class="nav-text">问题二：错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题三：条件执行很困难并且容易出错"><span class="nav-number">2.3.</span> <span class="nav-text">问题三：条件执行很困难并且容易出错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题四：实在太容易出错了"><span class="nav-number">2.4.</span> <span class="nav-text">问题四：实在太容易出错了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"><span class="nav-number">2.5.</span> <span class="nav-text">问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方案：async-await"><span class="nav-number">3.</span> <span class="nav-text">解决方案：async/await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#挂起点"><span class="nav-number">3.1.</span> <span class="nav-text">挂起点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步调用"><span class="nav-number">3.2.</span> <span class="nav-text">异步调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#详细设计"><span class="nav-number">4.</span> <span class="nav-text">详细设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#异步函数"><span class="nav-number">4.1.</span> <span class="nav-text">异步函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步函数类型"><span class="nav-number">4.2.</span> <span class="nav-text">异步函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Await表达式"><span class="nav-number">4.3.</span> <span class="nav-text">Await表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">4.4.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载和重载解析"><span class="nav-number">4.5.</span> <span class="nav-text">重载和重载解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动闭包"><span class="nav-number">4.6.</span> <span class="nav-text">自动闭包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码兼容性"><span class="nav-number">5.</span> <span class="nav-text">源码兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对ABI稳定性的影响"><span class="nav-number">6.</span> <span class="nav-text">对ABI稳定性的影响</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对API弹性的影响"><span class="nav-number">7.</span> <span class="nav-text">对API弹性的影响</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junjie Lu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
