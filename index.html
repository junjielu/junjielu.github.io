<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.jpg?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Ballad">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ballad">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ballad">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Ballad</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ballad</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-snippets">
          <a href="/develop/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br>
            
            片段
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/09/asyncawait/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/09/asyncawait/" itemprop="url">Async/await</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-09T00:15:17+08:00">
                2020-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文链接：<a href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md" target="_blank" rel="noopener">Async/await proposal</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现代Swift开发会涉及到大量的异步编程，一般来说我们通过回调来完成，但是回调的api非常难以使用。当代码涉及了非常多的异步操作，还要进行错误处理，并且回调之间互相依赖时，这会带来非常大的麻烦。本提议描述了对语言的拓展，让这一切变得更自然更不易出错。</p>
<p>我们打算为Swift引入协程的模型。函数可以是异步的，这让程序员们能够使用正常的控制流来编写包含异步操作的复杂逻辑。编译器负责将异步函数转换为一组适当的闭包和状态机。</p>
<p>这个提议定义了异步函数的语义，但是不提供并发行，并发性相关建议会在另外一个提议中详细阐述。并发性的提议会将异步函数与并发执行的任务相关联，并提供创建、查询和取消任务的api。</p>
<p>本提议从Chris Lattner和Joe Groff之前写的一个提议中得到了很多启发。提议本身源于<a href="https://gist.github.com/oleganza/7342ed829bddd86f740a" target="_blank" rel="noopener">Oleg Andreev的提议</a>。显然，很多内容都经过了重写，细节也发生了改变，但是核心思想仍然是一致的。</p>
<h2 id="动机：回调不是最优解"><a href="#动机：回调不是最优解" class="headerlink" title="动机：回调不是最优解"></a>动机：回调不是最优解</h2><p>在异步编程中使用显式回调（也称为完成回调）有许多问题，我们将在下面探讨这些问题。提议通过在语言中引入异步函数来解决这些问题。异步函数允许将异步代码写成单行的形式。它们还能实现直接推断代码的执行模式，从而让回调更有效地运行。</p>
<h3 id="问题一：回调地狱"><a href="#问题一：回调地狱" class="headerlink" title="问题一：回调地狱"></a>问题一：回调地狱</h3><p>一系列简单的异步操作通常需要深度嵌套的闭包。下面是一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1</span><span class="params">(completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource <span class="keyword">in</span></span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource <span class="keyword">in</span></span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp <span class="keyword">in</span></span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData1 &#123; image <span class="keyword">in</span></span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种回调地狱使得阅读和跟踪代码运行的位置变得非常困难。此外，使用一堆闭包会导致许多二阶效应，我们将在下文中讨论。</p>
<h3 id="问题二：错误处理"><a href="#问题二：错误处理" class="headerlink" title="问题二：错误处理"></a>问题二：错误处理</h3><p>回调使错误处理变得非常困难和冗长。Swift 2为同步代码引入了一个错误处理模型，但是基于回调的接口并没有从中得到任何好处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> imageTmp = imageTmp <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> imageResult = imageResult <span class="keyword">else</span> &#123;</span><br><span class="line">                        completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; image, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123;</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Result</code>的加入让Swift的api在错误处理这一块得到了提升。异步api也是<code>Result</code>的引入的一个重要动机：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(Result&lt;Image&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResourceResult <span class="keyword">in</span></span><br><span class="line">        dataResourceResult.<span class="built_in">map</span> &#123; dataResource <span class="keyword">in</span></span><br><span class="line">            loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResourceResult <span class="keyword">in</span></span><br><span class="line">                imageResultResult.<span class="built_in">map</span> &#123; imageResource <span class="keyword">in</span></span><br><span class="line">                    decodeImage(dataResource, imageResource) &#123; imageTmpResult <span class="keyword">in</span></span><br><span class="line">                        imageTmpResult.<span class="built_in">map</span> &#123; imageTmp <span class="keyword">in</span> </span><br><span class="line">                            dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                                completionBlock(imageResult)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> image):</span><br><span class="line">        display(image)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用<code>Result</code>时，我们更容易正确地处理错误，从而缩短代码。但是，回调地狱问题仍然存在。</p>
<h3 id="问题三：条件执行很困难并且容易出错"><a href="#问题三：条件执行很困难并且容易出错" class="headerlink" title="问题三：条件执行很困难并且容易出错"></a>问题三：条件执行很困难并且容易出错</h3><p>通过执行异步函数是一件非常痛苦的事情。举个例子，假设我们需要在获得图像后对其进行<code>swizzle</code>。我们可能不得不在<code>swizzle</code>之前执行一些异步代码。也许构造这个函数的最好的函数是把swizzle的代码组织成一个逃逸闭包，并在异步函数的完成回调中被捕获，像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData3</span><span class="params">(recipient: Person, completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> swizzle: (contents: image) -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">      <span class="comment">// ... continuation closure that calls completionBlock eventually</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        swizzle(recipient.profilePicture)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeImage &#123; image <span class="keyword">in</span></span><br><span class="line">            swizzle(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种模式颠倒了一个函数自上而下的组织方式：在函数的后半部分执行的代码出现在了前半部分。除了重新构造整个函数之外，我们现在还必须仔细考虑闭包的捕获，因为这个闭包是在完成回调中使用的。随着条件执行的异步函数数量的增加，问题会进一步恶化，从而产生实质上的回调地狱。</p>
<h3 id="问题四：实在太容易出错了"><a href="#问题四：实在太容易出错了" class="headerlink" title="问题四：实在太容易出错了"></a>问题四：实在太容易出错了</h3><p>只需简单地返回，不调用正确的完成回调，就可以很容易地提前退出异步操作。当你搞忘了的时候，这个问题是很难调试的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData4</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你记得调用回调时，你仍然可能会忘记在调用回调之后返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData5</span><span class="params">(recipient:Person, completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> image = recipient.profilePicture &#123;</span><br><span class="line">            completionBlock(image) <span class="comment">// &lt;- forgot to return after calling the block</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是，<code>guard</code>语法在某种程度上让你避免了忘记返回的情况，但它并不能给你永远的保护。</p>
<h3 id="问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"><a href="#问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了" class="headerlink" title="问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"></a>问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了</h3><p>虽然很难量化，但笔者认为，使用回调的尴尬导致许多api被定义为同步行为，甚至在它们可能阻塞的时候。这可能会导致UI应用程序的性能和响应性问题，例如loading光标。它还会导致一些api无法在异步对规模至关重要的情况下使用，比如在服务器上。</p>
<h2 id="解决方案：async-await"><a href="#解决方案：async-await" class="headerlink" title="解决方案：async/await"></a>解决方案：async/await</h2><p>异步函数——通常称为<code>async/await</code>——允许异步代码像单行的同步代码一样编写。通过允许程序员充分使用同步代码可用的相同语言结构，它可以立即解决上面描述的许多问题。使用<code>async/await</code>也自然地保留了代码的语义结构，提供了至少三个对语言的改进所必需的信息：</p>
<ol>
<li>更好的异步代码性能</li>
<li>更好的工具，在调试、剖析和探索代码时提供更一致的体验</li>
<li>为将来的并发特性（如任务的优先级和取消）奠定基础。</li>
</ol>
<p>我们使用前面的例子演示一下<code>async/await</code>如何大大简化异步代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadWebResource</span><span class="params">(<span class="number">_</span> path: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Resource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(<span class="number">_</span> r1: Resource, <span class="number">_</span> r2: Resource)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dewarpAndCleanupImage</span><span class="params">(<span class="number">_</span> i : Image)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = await <span class="keyword">try</span> loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = await <span class="keyword">try</span> loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageTmp      = await <span class="keyword">try</span> decodeImage(dataResource, imageResource)</span><br><span class="line">  <span class="keyword">let</span> imageResult   = await <span class="keyword">try</span> dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多关于<code>async/await</code>的实现描述都是一个通用的机制：将函数切割为多个部分的编译器传递。这在抽象的底层层次上理解机器是如何运行的是很重要的，但在更高层次上，我们希望您忽略它。相反，可以将异步函数看作具有放弃线程的特殊能力的普通函数。异步函数通常不会直接使用这种能力；相反，它们只是进行方法调用，有时这些调用将要求它们放弃线程并等待某些事情发生。当该操作完成时，函数将继续执行。</p>
<p>这与同步函数有很强的相似性。同步函数的调用会在调用完成前等待，在调用完成后返回。一旦调用完成，控制流会回到调用时的位置并从它停止的地方继续。异步函数也是如此：它可以像往常一样调用；当进行调用时，它通常会立即等待调用的完成。一旦调用完成，控制权就返回到函数，恢复到原来的位置。唯一的区别是同步函数可以充分利用部分它们的线程及其堆栈，而异步函数可以完全放弃堆栈而使用它们自己单独的存储区域。异步函数的这种额外功能有一些实现成本，但我们可以通过围绕它进行整体设计来降低成本。</p>
<p>因为异步函数必须能够放弃自己的线程，而同步函数不知道如何放弃一个线程，所以同步函数通常不能调用异步函数：异步函数只能放弃它占领的线程的一部分。如果进行一下这样的尝试，同步函数中调用一个异步函数，同步函数需要等待异步函数的返回。一般来说，实现这一功能的唯一方式是阻塞整个线程，直到异步函数恢复并完成，那这将完全违背异步函数的目的，并会造成恶劣的系统影响。</p>
<p>相反，异步函数既可以调用同步函数也可以调用异步函数。当然，在调用同步函数时，它不能放弃线程。实际上，异步函数不会直接放弃线程；它们只有在到达所谓的挂起点时才会放弃线程，挂起点就是<code>await</code>。挂起点可以直接发生在一个函数中，也可以发生在该函数调用的另一个异步函数中，但在任何一种情况下，该函数及其所有异步调用者都会同时放弃线程。(在实践中，异步函数在编译时不依赖于异步调用期间的线程，因此只有最内层的函数需要做一些额外的工作。)</p>
<p>当控制流返回到一个异步函数时，它会准确地恢复到原来的位置。这并不一定意味着它将在与之前完全相同的线程上运行，因为语言层不能保证在挂起之后会这样做。在这种设计中，线程主要是一种实现机制，而不是预期的并发接口的一部分。然而，许多异步函数并不仅仅是异步的：它们还与特定的<code>actor</code>相关联，并且它们总是作为<code>actor</code>的一部分运行。Swift保证这些函数实际上将返回到其<code>actor</code>以完成执行。因此，直接使用线程进行状态隔离的库——例如，通过创建自己的线程并在线程上顺序调度任务——通常应该在Swift中将这些线程转化为<code>actor</code>，以在Swift中保证正常运行。</p>
<h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>挂起点是执行异步函数时放弃线程的点。挂起点总是与函数中一些确定性的、语法上明确的事件相关联；从函数的角度来看，它们不会是被隐藏的或异步的。详细的语言设计将把几个不同的操作描述为挂起点，但最重要的一个操作是对与不同上下文的异步函数的调用。</p>
<p>重要的是，挂起点只与显式操作相关联。事实上，这个提议要求将可能暂停的调用封装在一个<code>await</code>表达式中，这是非常重要的。这沿袭了Swift使用<code>try</code>表达式来处理可能引发错误的函数调用的先例。标记挂起点特别重要，因为挂起中断了原子性。例如，如果一个异步函数在一个受串行队列保护的上下文中运行，达到一个挂起点意味着其他代码可以交错在同一串行队列上。原子性的重要性可以体现在一个经典但有点老旧的例子：如果存款被存入一个帐户，但操作在处理匹配的取款之前暂停，那么它将创建一个时间窗口，在该窗口中可以重复使用这些资金。对许多Swift程序员来说，一个更贴切的例子是UI线程：挂起点是UI可以显示给用户的点，因此程序构建部分UI然后挂起的风险是呈现一个卡住了的、部分构造的UI。(注意，代码中也使用显式回调显式地调用挂起点：挂起发生在外部函数返回点和回调开始运行点之间。)我们要求所有的挂起点都被标记，这使得程序员可以安全地假定没有挂起点的地方将按照原子方式运行，并且更容易识别出有问题的非原子模式。</p>
<p>由于挂起点只能出现在异步函数中被显式标记的点上，因此长时间的计算仍然会阻塞线程。当调用一个只做大量工作的同步函数时，或者遇到直接在异步函数中编写的特别密集的计算循环时，可能会发生这种情况。在任何一种情况下，线程都不能在这些计算运行时交错代码，这通常是正确的选择，但也可能成为延展性问题。需要进行密集计算的异步程序通常应该在单独的上下文中运行。当这不可行的时候，将会有一些工具来人为地挂起并允许其他操作进行交叉。</p>
<p>异步函数应该避免调用那些实际上会阻塞线程的函数，特别是当它们阻塞线程的目的是等待哪些不能保证当前正在运行的工作完成的时候。例如，获取互斥锁的行为只能被阻塞，直到当前运行的线程放弃该互斥锁；这有时是可以接受的，但必须谨慎使用，以避免引入死锁或人为的延展性问题。相反，等待一个条件变量可能会阻塞，直到某个工作被调度，并通知该变量；这种模式与推荐的方式是背道而驰的。需要做一些工作来让程序避免这些缺陷。</p>
<p>当异步函数在另一个上下文中等待操作时，此设计目前没有提供阻止当前上下文并切换的函数。这种省略是有意为之的：为了防止出现死锁。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>对<code>async</code>函数的调用看上去和实际运行上都很像对同步函数的调用。调用一个<code>async</code>函数的语义是：</p>
<ul>
<li>参数是使用普通规则计算的，包括对任何inout参数的初始访问。</li>
<li>被调用者的执行者是确定的。该提议没有说明确定执行者的规则；参见关于<code>actor</code>的补充建议。</li>
<li>如果被调用者的执行者与调用者的执行者不同，则会发生挂起，在被调用者中恢复执行的部分任务会安排到被调用者的执行程序上。</li>
<li>被调用者在其执行者上使用给定的参数执行。</li>
<li>在返回期间，如果被调用者的执行者与调用者的执行者不同，则会发生挂起，并且在调用者中恢复执行的部分任务会安排到调用者的执行程序中。</li>
<li>最后，调用者在它的执行者上继续执行。如果被调用方正常返回，则调用表达式的结果为函数返回的值；否则，表达式将抛出被调用方抛出的错误。</li>
</ul>
<p>从调用方的角度来看，异步调用的行为类似于同步调用，除了它们可能在不同的执行者上执行，需要任务被暂时挂起。还要注意的是，由于调用上的挂起，inout访问的持续时间可能要长得多，因此inout对共享的可变状态的引用没有充分隔离，更有可能产生动态排他性冲突。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>函数类型可以显式标记为<code>async</code>，表示函数是异步的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collect</span><span class="params">(function: <span class="params">()</span></span></span> async -&gt; <span class="type">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>函数或初始化声明也可以显式声明为<code>async</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(hiringFrom: <span class="type">College</span>) async <span class="keyword">throws</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">raiseHand</span><span class="params">()</span></span> async -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对声明为<code>async</code>的函数的引用以及初始化方法均是<code>async</code>函数类型 。如果引用是对实例方法的柯里化的静态引用，则内层的函数类型是异步的，这与此类引用的规则是一致的。</p>
<p>一些特殊的函数，比如<code>deinit</code>以及存储访问器不能标为<code>async</code>。</p>
<blockquote>
<p>原理阐述：只有getter的属性可能是<code>async</code>的。但是，同样具有异步setter的属性意味着能够将属性作为inout传递并深入到该属性本身，这取决于setter是否有效地是一个同步操作。禁止异步属性比只允许get的异步属性更简单。</p>
</blockquote>
<p>如果一个函数既是<code>async</code>又是<code>throws</code>，那么在声明时，<code>async</code>必须在<code>throws</code>之前。同样的规则也被应用在<code>async</code>和<code>rethrows</code>上。</p>
<blockquote>
<p>原理阐述：这种顺序限制没有很特别的理由，但它没有坏处，而且它消除了对风格的潜在争论。</p>
</blockquote>
<h3 id="异步函数类型"><a href="#异步函数类型" class="headerlink" title="异步函数类型"></a>异步函数类型</h3><p>异步函数类型不同于同步函数类型。不存在从同步函数类型到相应异步函数类型的隐式转换。但是，将非抛出异步函数类型的值隐式转换为相应的抛出异步函数类型是允许的。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctionTypes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> syncNonThrowing: () -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> syncThrowing: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> asyncNonThrowing: () async -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> asyncThrowing: () async <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">  </span><br><span class="line">  mutable <span class="function"><span class="keyword">func</span> <span class="title">demonstrateConversions</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Okay to convert to throwing form</span></span><br><span class="line">    syncThrowing = syncNonThrowing</span><br><span class="line">    asyncThrowing = asyncNonThrowing</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error to convert between asynchronous and synchronous</span></span><br><span class="line">    asyncNonThrowing = syncNonThrowing <span class="comment">// error</span></span><br><span class="line">    syncNonThrowing = asyncNonThrowing <span class="comment">// error</span></span><br><span class="line">    asyncThrowing = syncThrowing       <span class="comment">// error</span></span><br><span class="line">    syncThrowing = asyncThrowing       <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以手动创建一个调用同步函数的<code>async</code>闭包，因此缺少隐式转换不会有表达能力上的影响。有关定义<code>async</code>闭包的语法，请参阅“闭包”一节。</p>
<blockquote>
<p>原理阐述：我们不建议使用从同步函数到异步函数的隐式转换，因为这会使类型检查复杂化，特别是在存在同一函数的同步和异步重载的情况。有关更多信息，请参阅“重载和重载解析”一节。</p>
</blockquote>
<h3 id="Await表达式"><a href="#Await表达式" class="headerlink" title="Await表达式"></a>Await表达式</h3><p>对<code>async</code>函数类型的值的调用（包括对<code>async</code>函数的直接调用）带来了一个挂起点。任何挂起点都必须发生在一个异步的上下文中（例如，一个<code>async</code>函数）。而且，它必须出现在<code>await</code>表达式的操作中。</p>
<p>看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func redirectURL(for url: URL) async -&gt; URL &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// func dataTask(with: URL) async throws -&gt; URLSessionDataTask &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newURL = await server.redirectURL(<span class="keyword">for</span>: url)</span><br><span class="line"><span class="keyword">let</span> (data, response) = await <span class="keyword">try</span> session.dataTask(with: newURL)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，一个任务的挂起可能发生在<code>redirectURL(for:)</code>和<code>dataTask(with:)</code>中，因为它们都是异步函数。因此，两个调用表达式都必须包含在<code>await</code>表达式中，因为它们都包含了挂起点。尽管在<code>await</code>的操作中允许有多个挂起点，但<code>await</code>表达式的操作必须至少包含一个挂起点。例如，我们可以使用一个<code>await</code>来覆盖两个挂起点来重写上面的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (data, response) = await <span class="keyword">try</span> session.dataTask(with: server.redirectURL(<span class="keyword">for</span>: url))</span><br></pre></td></tr></table></figure></p>
<p><code>await</code>没有其他的语义；像<code>try</code>一样，它只是标记正在进行异步调用。<code>await</code>表达式的类型是它的操作者的类型，返回结果是其操作者的结果。</p>
<blockquote>
<p>原理阐述：重要的是，异步调用必须在函数内被清晰地识别，因为它们引入了挂起点，这会破坏操作的原子性。挂起点可能是调用所固有的（因为异步调用必须在不同的执行者上执行），或者仅仅是被调用者实现的一部分，但是在任何一种情况下，它在语义上都是重要的，程序员需要有正确的认识。<code>await</code>表达式也是异步代码的指示符，它与闭包中的推断相关联；更多信息请参见“闭包”一节。</p>
</blockquote>
<p>挂起点不能出现在非<code>async</code>函数类型的自动闭包中。</p>
<p>挂起点不能出现在<code>defer</code>的block中。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个闭包可以具有<code>async</code>的函数类型。这样的闭包可以明确地标记为<code>async</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; () async -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> await getInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果匿名闭包包含一个<code>await</code>表达式，则推断它具有<code>async</code>函数类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closure = &#123; await getInt() &#125; <span class="comment">// implicitly async</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure2 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>     <span class="comment">// implicitly async</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> await getInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对闭包的<code>async</code>推断不会延伸到它的封闭性、嵌套函数或闭包，因为这些上下文不论异步或同步都是可分离的。例如，只有<code>closure6</code>在这种情况下被推断为<code>async</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func getInt() async -&gt; Int &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure5 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>       <span class="comment">// not 'async'</span></span><br><span class="line">  <span class="keyword">let</span> closure6 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>     <span class="comment">// implicitly async</span></span><br><span class="line">    <span class="keyword">if</span> randomBool() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"there"</span>)</span><br><span class="line">      <span class="keyword">return</span> await getInt()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> closure7 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="number">7</span> &#125;  <span class="comment">// not 'async'</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载和重载解析"><a href="#重载和重载解析" class="headerlink" title="重载和重载解析"></a>重载和重载解析</h3><p>现有的包含一个操作同步和异步入口的Swift程序，可能会为每个操作使用两种命名相似的方法来设计：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(completionHandler: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在调用方看来上，通过是否传入回调可以清楚地了解正在调用哪个方法。然而，随着第二种方法的api直接映射到一个<code>async</code>函数，这两种方法现在非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> async -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">doSomething() <span class="comment">// synchronous or asynchronous?</span></span><br></pre></td></tr></table></figure>
<p>如果我们用<code>throws</code>替换<code>async</code>，声明上面的两个方法会产生一个“invalid redeclaration”的编译错误。但是，我们建议允许<code>async</code>函数重载非<code>async</code>函数，因此上面的代码是没问题的。这允许现有的Swift程序发展现有同步函数的<code>async</code>版本，而不会产生虚假的重命名。</p>
<p>重载<code>async</code>和非<code>async</code>函数的能力与重载解析规则相对应，根据调用的上下文选择适当的函数。对于一个调用，重载解析倾向于在同步上下文中使用非<code>async</code>函数，因为这样的上下文中不能包含对异步函数的调用。此外，重载解析倾向于在异步上下文中使用<code>async</code>函数，因为当有替代方法时，这样的上下文应该避免同步、阻塞api。当重载解析选择一个<code>async</code>函数时，该调用必须发生在一个await表达式中。</p>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>除非函数本身是<code>async</code>，否则函数不能使用<code>async</code>函数类型的自动闭包参数。例如，下面的声明格式是不正确的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: async autoclosure in a function that is not itself 'async'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeArgumentLater</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: @escaping @autoclosure <span class="params">()</span></span></span> async -&gt; <span class="type">T</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这一限制的存在有几个原因。考虑下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func getIntSlowly() async -&gt; Int &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  computeArgumentLater(await getIntSlowly())</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，<code>await</code>表达式告诉程序员调用<code>computeArgumentLater(_:)</code>会有一个挂起点，实际上并不是这样：挂起点位于被<code>computeArgumentLater(_:)</code>使用和传递的自动闭包内部。这导致了一些问题。首先，<code>await</code>出现在调用上这一事实意味着我们将推断闭包具有<code>async</code>函数类型，然而这也是不正确的：闭包中的所有代码都是同步的。其次，因为一个<code>await</code>的操作只需要包含一个暂停点在它的某个位置，一个等效的重写的调用应该是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await computeArgumentLater(getIntSlowly())</span><br></pre></td></tr></table></figure>
<p>但是，因为参数是一个自动闭包，所以这种重写没有保留它语义。因此，对<code>async</code>自动闭包参数的限制确保<code>async</code>自动闭包参数只能在异步上下文中使用，从而避免了这些问题。</p>
<h2 id="源码兼容性"><a href="#源码兼容性" class="headerlink" title="源码兼容性"></a>源码兼容性</h2><p>这个提议基本上只是一些新的添加：现有代码不会使用任何新特性（例如，不创建<code>async</code>函数或闭包），因此不会受到影响。但是，它引入了两个新的上下文关键字：<code>async</code>和<code>await</code>。</p>
<p>语法中<code>async</code>的用法位置（函数声明、函数类型和作为<code>let</code>的前缀）允许我们将async作为上下文关键字处理，而不会破坏源代码的兼容性。用户定义的<code>async</code>不能出现在代码的相应语法位置中。</p>
<p><code>await</code> 这个上下文相关的关键字有一些问题，因为它发生在表达式中。例如，我们可以在Swift中定义一个功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">await</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; x + y &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = await(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这是一段格式良好的代码，它是对<code>await</code>函数的调用。根据这个提议，这段代码变成了一个带有子表达式(1,2)的<code>await</code>表达式，这对于现有的Swift程序来说是一个编译时错误，因为等待只能在异步上下文中使用，而且现有的Swift程序没有这样的上下文。这样的函数看起来并不常见，所以我们认为这是引入<code>async/await</code>时可以接受的源码破坏。</p>
<h2 id="对ABI稳定性的影响"><a href="#对ABI稳定性的影响" class="headerlink" title="对ABI稳定性的影响"></a>对ABI稳定性的影响</h2><p>无</p>
<h2 id="对API弹性的影响"><a href="#对API弹性的影响" class="headerlink" title="对API弹性的影响"></a>对API弹性的影响</h2><p>无</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/07/swiftconcurrencyroadmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/07/swiftconcurrencyroadmap/" itemprop="url">Swift并发路线图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-07T17:42:57+08:00">
                2020-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文是<a href="https://github.com/airspeedswift/swift/blob/concurrency-roadmap/docs/ConcurrencyRoadmap.md" target="_blank" rel="noopener">SwiftConcurrencyRoadmap</a>的中文翻译</p>
</blockquote>
<p>我们的目标是使Swift在并发编程方面方便、高效和安全。</p>
<p>本文概述了对语言的一些添加和更改来实现<strong>asynchronous functions</strong>和<strong>actor</strong>的特性。这些提议将被分别提出，但在许多情况下它们将相互依赖。此文档用于对它们进行统一。宣言可能描述多个可能的方向，与此不同，本文描述了处理Swift并发性的单一计划。</p>
<p>这些即将产生的变化将会带来的是：</p>
<ul>
<li>异步编程更方便和清晰</li>
<li>提供一套标准的工具和技术，让swift开发者能够获得指引</li>
<li>优化编译期处理以提升异步代码的性能</li>
<li>以和消除内存不安全性同样的方式消除竞态条件和死锁</li>
</ul>
<p>这些特性的引入将跨越多个Swift版本。功能的引入大致分为两个阶段。第一个阶段引入异步语法和actor类型；这将允许用户以一种减少(而不是消除)数据竞争的方式来组织Actor的代码。第二阶段将强制执行完整的<code>Actor Isolation</code>，消除数据竞争，同时也将带来一些特性，实现高效和符合人体工程学的Actor交互操作，从而使隔离成为现实。</p>
<p>作为路线图，本文不像那些具体的proposal那样详细。本文还讨论了第二阶段的功能，但该阶段的详细建议将会在第一个阶段得到更好地定义之后再进行补充。</p>
<p>还有许多其他相关主题没有在本文档中介绍，比如异步流、并行for循环和分布式Actor。这些特性中的许多都是对路线图中所描述内容的补充，可以在任何时候引入。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前，我们提倡的处理并发的基本模式是良好的：我们告诉大家应该使用队列而不是锁去保护状态，通过异步回调而不是阻塞的方式返回慢速操作的结果。</p>
<p>但是实际情况是我们可能会写出糟糕和容易出错的代码。看看下面的代码，你就会明白：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">(completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    refreshQueue.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.gameSession.allPlayers &#123; players <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.players = players.<span class="built_in">map</span>(\.nickname)</span><br><span class="line">            completion?()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有三点我们值得进行思考：</p>
<ul>
<li>我们写了非常多的<strong>公式代码</strong>，这个方法基本上只是进行一个简单调用，转换结果并赋值，但是处理线程和回调的代码太多了导致我们很难看清这个方法的本质</li>
<li>这些公式代码让<strong>产生bug变得更容易</strong>。我们在方法的回调中直接对<code>self.players</code>进行了赋值，那么这个赋值操作是在哪个线程上执行的呢？我们不清楚。所以这会带来潜在的数据竞争：回调可能需要被派发到正确的线程上执行。可能这个工作是<code>allPlayers</code>完成的，但我们无法根据现有的条件推断这段代码是否是线程安全的。</li>
<li>这段代码是低效的，尽管这是不必要的。首先，我们要分配几个方法对象的内存，对于像<code>self</code>这样的引用，我们必须拷贝到这些方法中，这带来了额外的引用计数的操作。这段代码可能会运行很多次，也可能根本不会运行，所以通常这使得编译器无法避免这些拷贝工作。</li>
</ul>
<p>此外，这些问题的耦合是不可避免的。异步回调一般来说总是准确地只运行一次，这意味着它们不会产生循环引用。由于Swift无法获知这一点，它要求<code>self</code>在闭包中显式地声明，所以一些程序员会条件反射地使用<code>[weak self]</code>。由于不得不处理<code>self</code>为空的情况，运行时开销和公式代码的增加也将无法避免。通常，当<code>self</code>为空时，这些方法会立即返回，这使得我们很难判断代码的正确性，因为任意量的代码可能会被跳过。</p>
<p>所以在这里基本模式没有问题，但是用swift进行表达会失去重要的结构信息并产生问题。解决方案是将这些基本模式引入到语言中。这将减少公式代码，并通过语言支持让基本模式更加安全，消除bug，并让程序员有信心更广泛地使用并发。也许它还将为我们提供一个提高并发代码性能的机会。</p>
<p>下面是使用我们提出的新语法重写的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">()</span></span> async &#123;</span><br><span class="line">  players = await gameSession.allPlayers().<span class="built_in">map</span>(\.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有几点值得注意：</p>
<ul>
<li><code>refreshPlayers</code>现在是<code>async</code>修饰的方法了</li>
<li><code>allPlayers</code>也是<code>async</code>修饰的方法，并且方法会返回结果而不是通过回调传递</li>
<li>我们可以使用表达式的组合去直接调用<code>map</code>方法</li>
<li><code>await</code>关键字表明<code>refreshPlayers</code>这个方法将会在这一刻被挂起</li>
<li><code>await</code>的表现与<code>try</code>类似，它只需要在表达式中出现一次就可以了</li>
<li>显式声明的<code>self.</code>被消除了，因为已经没有闭包对<code>self</code>进行捕获了</li>
<li><code>allPlayers</code>和<code>players</code>的访问不再会有数据竞争的情况了</li>
</ul>
<p>为了理解最后一点是如何实现的，我们必须走出来看看队列应该如何使用来保护状态。</p>
<p>原始代码是一个使用<code>refreshQueue</code>保护其内部状态:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerRefreshController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">var</span> gameSession: <span class="type">GameSession</span></span><br><span class="line">  <span class="keyword">var</span> refreshQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"PlayerRefresh"</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">(completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>) &#123; </span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一种常见的模式：类具有私有队列和一些只能在队列上访问的属性。现在我们用一个<code>actor</code>来替换这种方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="class"><span class="keyword">class</span> <span class="title">PlayerRefreshController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">var</span> gameSession: <span class="type">GameSession</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">()</span></span> async &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会注意到：</p>
<ul>
<li>我们将这个类用<code>actor</code>进行修饰，这与给类一个私有队列并在队列里维护内部状态的做法是类似的</li>
<li>你还是需要使用队列来保护状态：编译器将确保类的方法在指定的队列上运行，并且它将阻止你在方法之外去访问这些状态。</li>
<li>因为编译器负责执行此操作，所以它可以更聪明地进行优化，比如当方法的调用是在不同的<code>actor</code>上的时候。</li>
</ul>
<p>上面我们展示了一个<code>actor</code>类，其中有一组经过严密封装的属性和代码。但我们现在的UI编程方式通常是将代码分散到大量的类中，而这些类本应在一个主线程中使用。所以主线程仍然是一种<code>actor</code>——我们称之为<strong>global actor</strong>。</p>
<p>您可以使用属性将类和方法绑定到<code>actor</code>上。编译器将允许您从任何地方引用这个类，但是要真正调用这个方法，您需要在<strong>UI Actor</strong>上进行调用。因此，如果<code>PlayerRefreshController</code>的所有动作都适合在全局UI <code>actor</code>上执行，我们将这样表示它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">UIActor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerRefreshController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">var</span> gameSession: <span class="type">GameSession</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">()</span></span> async &#123;  ...  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对于第一阶段的提议"><a href="#对于第一阶段的提议" class="headerlink" title="对于第一阶段的提议"></a>对于第一阶段的提议</h2><p>我们会在未来数周提出以下提议，以开展第一阶段的工作：</p>
<ul>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md" target="_blank" rel="noopener">async / await</a>，引入基于<a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">协程</a>的模型结构。方法可以声明为<code>async</code>，并且可以等待其他<code>async</code>方法的结果返回，这使得异步代码的单行表达成为可能。相关的<a href="https://forums.swift.org/t/concurrency-asynchronous-functions/41619" target="_blank" rel="noopener">讨论</a>。</li>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/structured-concurrency/proposals/nnnn-structured-concurrency.md" target="_blank" rel="noopener">TaskAPI and Structured Concurrency</a>，为标准库引入<code>task</code>的概念。api将提供包括<code>detached tasks</code>、用于动态创建<code>child tasks</code>的<code>task &quot;nurseries&quot;</code>，以及<code>task</code>的取消及优先级机制。它还将引入基于范围的机制来等待多个子<code>task</code>的返回值，机制设计的原则基于<a href="https://en.wikipedia.org/wiki/Structured_concurrency" target="_blank" rel="noopener">Structured concurrency</a>。相关的<a href="https://forums.swift.org/t/concurrency-structured-concurrency/41622" target="_blank" rel="noopener">讨论</a>。</li>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/actors/proposals/nnnn-actors.md" target="_blank" rel="noopener">Actors &amp; Actor Isolation</a>，这为并行编程提供了状态隔离，通过这种机制可以消除潜在的数据竞争。第一阶段的提议将引入部分<code>Actor Isolation</code>，将完全隔离留给下一阶段。相关的<a href="https://forums.swift.org/t/concurrency-actors-actor-isolation/41613" target="_blank" rel="noopener">讨论</a>。</li>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/concurrency-objc/proposals/NNNN-concurrency-objc.md" target="_blank" rel="noopener">Concurrency Interoperability with Objective-C</a>，它将为swift的并行特性（比如<code>async</code>方法）和Objective-C的一些约定俗成的异步方法表达提供自动桥接。这将允许现有的异步Objective-C api在swift的并发模型中立即可用，做法是为swift的转换提供两个选择，一个是直接转换为<code>async</code>方法，另外一个向后兼容提供基于回调的版本。相关的<a href="https://forums.swift.org/t/concurrency-interoperability-with-objective-c/41616" target="_blank" rel="noopener">讨论</a>。</li>
<li><strong>Async handlers</strong>，它提供了声明同步的<code>actor</code>方法为一个异步处理的能力。这些方法的表现非常像一个同步方法，但是在内部，他们会被异步处理。这将允许一些传统的通知概念（比如<code>UITableViewDelegate</code>）去异步地执行而无需繁琐的设置。</li>
</ul>
<h2 id="Actor-Isolation以及第二阶段"><a href="#Actor-Isolation以及第二阶段" class="headerlink" title="Actor Isolation以及第二阶段"></a>Actor Isolation以及第二阶段</h2><p>我们的目标是在正常情况下防止可变状态上的数据竞争。实现此目的的系统称为<code>Actor Isolation</code>，这是因为<code>actor</code>是整套机制能够得以实现的核心概念，而且这套机制的重点将放在防止<code>actor</code>外部访问<code>actor</code>保护的状态。然而，在需要确保系统在并发状态下的正确性时，<code>Actor Isolation</code>机制同样会对代码做出限制，即使在<code>actor</code>没有直接参与的情况下。</p>
<p>我们打算分两个阶段介绍路线图中描述的特性：首先介绍创建异步方法和<code>actor</code>的能力；第二，实施完整的<code>Actor Isolation</code>。</p>
<p><code>Actor Isolation</code>的基本思想与<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0176-enforce-exclusive-access-to-memory.md" target="_blank" rel="noopener">独占访存</a>的思想类似，并以此为基础。Swift的并发设计旨在通过从<code>actor</code>的自然隔离开始，然后使用所有权作为补充工具，提供一种易于使用和可组合的安全并发方法。</p>
<p><code>Actor Isolation</code>问题将被简化为确保所有普通的可变内存仅由特定的<code>actor</code>或<code>task</code>访问的问题。这进而简化为如何访问内存以及谁可以优先访问的分析。我们可以把情况分成这样几类：</p>
<ul>
<li><code>actor</code>的属性将会被被<code>actor</code>所保护</li>
<li>不可变内存（比如<code>let</code>变量）、局部内存（比如完全不会被被捕获的本地变量），以及值类型内存（比如结构体的属性或者枚举），将会被保护，不会产生数据竞争</li>
<li>不安全的内存（如<code>UnsafeMutablePointer</code>引用的任意内存）与不安全的抽象相关联。试图做到安全地使用这些抽象是不可取的，因为这些抽象的目的是在必要时可以用来绕过安全的语言规则。相反，我们寄希望于程序员会正确使用这些类型。</li>
<li>全局内存（如全局或静态变量）原则上可以被任何地方的代码访问，所以会出现数据竞争。</li>
<li>类相关的内存也可以从任何持有该类的引用的代码中访问。这意味着，虽然对类的引用可能受到<code>actor</code>的保护，但在<code>actor</code>之间传递该引用会使其属性暴露在数据竞争中。这也包括在值类型中持有的对类的引用，当这些引用在<code>actor</code>之间传递时。</li>
</ul>
<p>完整的<code>Actor Isolation</code>的目标是确保这最后两种情况受到保护。</p>
<h3 id="第一阶段：基本的Actor-Isolation"><a href="#第一阶段：基本的Actor-Isolation" class="headerlink" title="第一阶段：基本的Actor Isolation"></a>第一阶段：基本的<code>Actor Isolation</code></h3><p>第一阶段带来了安全性上的好处。人们将能够用全局<code>actor</code>保护全局变量，并通过将其转换为<code>actor</code>类来保护类成员。需要在特定队列上进行访问的框架可以定义一个全局行为体，并为其提供默认协议。</p>
<p>在这一阶段，一些重要的<code>Actor Isolation</code>将被强制执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> immutable: <span class="type">String</span> = <span class="string">"42"</span></span><br><span class="line">  <span class="keyword">var</span> mutableArray: [<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">synchronousFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutableArray += [<span class="string">"syncFunction called"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyActor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">asyncFunction</span><span class="params">(other: MyActor)</span></span> async &#123;</span><br><span class="line">    <span class="comment">// allowed: an actor can access its internal state, even in an extension</span></span><br><span class="line">    <span class="keyword">self</span>.mutableArray += [<span class="string">"asyncFunction called"</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// allowed: immutable memory can be accessed from outside the actor</span></span><br><span class="line">    <span class="built_in">print</span>(other.immutable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: an actor cannot access another's mutable state</span></span><br><span class="line">    otherActor.mutableArray += [<span class="string">"not allowed"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: either reading or writing</span></span><br><span class="line">    <span class="built_in">print</span>(other.mutableArray.first)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allowed: async functions can call async functions on other actors</span></span><br><span class="line">    await other.asyncFunction(otherActor: <span class="keyword">self</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error: only asynchronous functions can be called from outside the actor</span></span><br><span class="line">    other.synchronousFunction()    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些改变不会对现有的swift代码带来改变，因为<code>actor</code>和<code>async</code>是一个新特性。</p>
<h3 id="第二阶段：完整的Actor-Isolation"><a href="#第二阶段：完整的Actor-Isolation" class="headerlink" title="第二阶段：完整的Actor Isolation"></a>第二阶段：完整的<code>Actor Isolation</code></h3><p>即使在引入<code>actor</code>之后，全局变量和引用类型的值，仍然存在数据竞争的可能性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> racyGlobal: [<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line">@<span class="type">MyGlobalActor</span></span><br><span class="line"><span class="keyword">var</span> safeGlobal: [<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainOldClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> unprotectedState: <span class="type">String</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor <span class="class"><span class="keyword">class</span> <span class="title">RacyActor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> immutableClassReference: <span class="type">PlainOldClass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">racyFunction</span><span class="params">(other: RacyActor)</span></span> async &#123;</span><br><span class="line">    <span class="comment">// protected: global variable protected by a global actor</span></span><br><span class="line">    safeGlobal += [<span class="string">"Safe access"</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// unprotected: global variable not in an actor</span></span><br><span class="line">    racyGlobal += [<span class="string">"Racy access"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unprotected: racyProperty is immutable, but it is a reference type</span></span><br><span class="line">    <span class="comment">// so it allows access to unprotected shared mutable type</span></span><br><span class="line">    other.takeClass(immutableClassReference)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">takeClass</span><span class="params">(<span class="number">_</span> plainClass: PlainOldClass)</span></span> &#123;</span><br><span class="line">    plainClass.unprotectedState += [<span class="string">"Racy access"</span>]  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一阶段，我们打算保留Swift目前的行为：全局变量和引用类型的内存不会受到保护。因此<code>actor</code>对于它们来说也不是安全的。因为这是swift目前的行为，所以这也不会对现有的swift代码带来改变。</p>
<p>在第二阶段，我们将引入一套工具链来处理完整的<code>Actor Isolation</code>。其中最重要的一点是将一个类型限制为<code>local actor</code>。当一个类型被标记为<code>local actor</code>时，编译器将阻止它在<code>actor</code>之间传递。引用需要通过某种方式进行拷贝或者以非共享的方式进行跨域传递。</p>
<p>这反过来又会对默认情况作出改变：</p>
<ul>
<li>全局变量将被要求由一个<code>global actor</code>保护，或标记为 <code>unsafe actor</code>。</li>
<li>类（和包含类引用的类型）将从默认的 <code>unsafe actor</code>变为<code>local actor</code>。</li>
</ul>
<p>这种改变将需要现有的Swift代码能够进行兼容，并且需要通过语言层来把关。触及可变的全局变量或跨<code>actor</code>边界共享的类引用，从根本上无法证明其不受数据竞争的影响，将需要改变以确保其免受数据竞争的影响（通过未来的代码）。希望这个兼容不会很繁琐：</p>
<ul>
<li>我们预期全局变量的使用应该是克制的，而且大多数全局变量可以由<code>global actor</code>保护;</li>
<li>只要类没有跨<code>actor</code>边界进行共享，<code>local actor</code>就不应该影响<code>actor</code>内部的代码;</li>
<li>在必须跨边界传递引用的地方，语言应该让这一点显现出来，解决方案也应该简单;</li>
<li>通过进一步鼓励和简化值类型的使用，跨边界共享的需求将会减少;</li>
<li>这两个阶段之间的时间将使用户有机会将他们的代码分解为<code>actor</code>和<code>async</code>方法，为完全隔离做好准备。</li>
</ul>
<p>与第一阶段的讨论不同，第二阶段需要的语言特性将首先在swift论坛的演化讨论版提出讨论。采取两个阶段的主要驱动因素之一是希望在转移到完全隔离模型之前给swift用户以时间来适应<code>async</code>方法和<code>actor</code>。将代码移植到<code>actor</code>和<code>async</code>方法的经验将告诉我们执行完全<code>Actor Isolation</code>所需的功能。这个反馈应该会反哺第二阶段的特性讨论。</p>
<p>预计将在第二阶段讨论的功能包括：</p>
<ul>
<li>引入<code>actorlocal</code>的限制类型</li>
<li>通过<code>mutableIfUnique</code>类类型，编译器能正确处理“写入拷贝”类型;</li>
<li>属性可选择退出<code>Actor Isolation</code>，例如通过其他方法处理线程安全的情况。</li>
</ul>
<h2 id="基本概念表"><a href="#基本概念表" class="headerlink" title="基本概念表"></a>基本概念表</h2><p>这些是将在整个设计中使用的基本概念，在这里简要定义：</p>
<ul>
<li><strong>synchronous function</strong>是Swift程序员已经习以为常的同步方法：它在一个线程上运行到完成，除了它调用的任何同步方法外，没有交叉代码。</li>
<li><strong>thread</strong>是指底层硬件的线程概念。平台各不相同，但往往具有相同的基本特征：真正的并发性需要创建线程，但创建和运行线程的成本很高。C方法调用和普通的同步Swift方法，都需要使用一个线程。</li>
<li><strong>asynchronous function</strong>是一种新的方法，它不需要运行到完成一路畅通。中断会导致方法被挂起。挂起点是指异步方法中断其线程的点。</li>
<li><strong>task</strong>是异步运行的操作。所有异步方法都作为某个任务的一部分运行。当一个异步方法调用另一个异步方法时，该调用仍然是同一任务的一部分，即使该调用必须更改<code>actor</code>。任务类似于异步方法的线程。</li>
<li>异步方法可以创建<strong>child task</strong>。子任务继承父任务的一些结构，包括其优先级，但可以与父任务并发运行。但是，这种并发性是有限制的：创建子任务的方法必须等待子任务结束后才能返回。</li>
<li>一个程序希望能开启独立的并发工作通过使用<strong>detached task</strong>，而不是一个有边界的child task来超越上下文边界。</li>
<li><strong>partial task</strong>是可调度的工作单元。task中当前执行的方法被挂起时，就是部分任务的结束，并创建一个新的partial task来继续整个task的工作。</li>
<li><strong>executor</strong>是一种服务，它接受partial task的提交，并安排某个线程运行它们。当前运行的异步方法总是知道它在哪个executor上运行。如果提交给执行程序的部分task永远不会并发运行，则称为<strong>exclusive executor</strong>。</li>
<li><strong>actor</strong>是程序中可以运行代码的独立部分。它一次只能运行一段代码—也就是说，它充当exclusive executor—但是它运行的代码可以与其他<code>actor</code>运行的代码并发执行。</li>
<li>一个actor的状态会受到保护，只有该actor才能访问。实现这一点所需的系统称为<strong>actor isolation</strong>。Swift的长期目标是在默认情况下保证actor isolation。</li>
<li><strong>actor class</strong>是一个引用类型，它的每个实例都是一个单独的actor。它的受保护状态是它的实例属性，它的actor方法是它的实例方法。</li>
<li><strong>global actor</strong>是全局对象。它的受保护状态和actor方法可以分布在许多不同的类型中。它们可以标记为一个特定于actor的属性，在许多情况下Swift可以推断出这个属性。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/01/Why-heic-lost-rotation/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/01/Why-heic-lost-rotation/" itemprop="url">Why heic lost rotation?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-01T21:53:08+08:00">
                2020-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的项目中支持了heic的上传和展示。在iOS 14之前，一切都很美好，我们享受着heic带来的图片体积的减小。但是在iOS 14以及新的macOS中，事情发生了变化，非常多的heic图片的展示方向都和预想的不一样。这是怎么回事呢？</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的项目中在图片上传之前会对图片本身进行一些ImageI/O相关的处理。</p>
<p>首先，我们会将图片downsampling，对于图片的像素数量我们有一个最大的限制是15000000个像素。对于图片最短边的尺寸我们限制为1500个像素。也就是说，假设原图大小是3000<em>4000，我们会把图片缩放到1500</em>2000。实现原理是通过<em>WWDC18 session 219</em>介绍的方式，通过ImageI/O进行处理（详情见<a href="https://junjielu.github.io/2020/08/27/%E5%9B%BE%E7%89%87%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">图片渲染优化</a>）。</p>
<p>downsampling完成之后，我们会根据图片的类型进行compress。比如对于jpeg以及heic，我们会进行一个0.75 compress quality的压缩（经验值）。</p>
<h2 id="问题出在哪？"><a href="#问题出在哪？" class="headerlink" title="问题出在哪？"></a>问题出在哪？</h2><p>首先拿到heic原图和经过我们处理后的图片，通过<code>exiftool</code>打印图片的元信息，这里仅对相关的属性进行一个diff（左边是原图，右边是处理过的图片）：</p>
<p><img src="diff.png" alt=""></p>
<p>我们发现这个<code>Rotation</code>信息和之前的不一样了，于是我们合理怀疑一下是不是这个<code>Rotation</code>导致图片展示方向出了问题？</p>
<p>然而根据我们之前的经验和相关的苹果的文档，图片的方向是根据<code>Orientation</code>来进行计算的，而两边图片元信息中的<code>Orientation</code>的值都是一样的：<code>Rotate 90 CW</code>即顺时针旋转90度。这又是为什么呢？</p>
<p>后来我们得知，这个<code>Rotation</code>是heic独有的属性，因此我们推测，在新的系统上，苹果使用了这个<code>Rotation</code>来进行图片方向的判断。</p>
<h2 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h2><p>Fine，那为什么经过我们处理后的图片会丢失<code>Rotation</code>相关的信息呢？经过了几天各种各样乱七八糟的尝试以及各地各式的资料搜集，我们依旧没能找到答案，这个<code>Rotation</code>信息就这么没了。。。</p>
<p>于是我们作出了一个假设就是ImageI/O的处理就是会导致失去<code>Rotation</code>信息，那么我们解决的思路就分以下两种：</p>
<ul>
<li>不遗余力把这个<code>Rotation</code>信息找回来</li>
<li>在downsampling的时候让ImageI/O把图片先转一下</li>
</ul>
<p>第二个方案实现起来很简单，只需要在downsampling的时候把<code>kCGImageSourceCreateThumbnailWithTransform</code>设为true就好了，但是我们又会发现，转过来了之后在旧的iOS版本上，图片方向又是错的了，原因可能是在旧版本上系统是根据<code>Orientation</code>来判断图片方向的。。。</p>
<p>所以到目前为止，我们唯一稍微可行的方案是：在downsampling的时候把图片先转一下，在encode的阶段把meta data全丢掉，这样显示的就是对的，可这么做似乎并不优雅。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在一筹莫展之际，我随意地翻了翻ImageI/O相关的接口和注释，发现一个有趣的东西：<code>kCGImageDestinationImageMaxPixelSize</code>，这是一个在encode的时候的一个配置项，但是和downsampling的一个配置项非常像：<code>kCGImageSourceThumbnailMaxPixelSize</code>。</p>
<p>于是我有了一个大胆的假设，是不是真正的最佳实践并不是手动downsampling+encode，而是通过encode的配置项实现downsampling，反正图片编码也会进行downsampling。</p>
<p>于是我动手改造原来的代码，将手动downsampling的过程去掉，通过<code>CGImageDestinationAddImageFromSource</code>的方法传入图片的image source进行encode，而不是之前直接传入<code>CGImage</code>。果然，经过处理后的图片没有丢掉<code>Rotation</code>，我们得到了一个可能是完美的解决方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ImageI/O相关的文档和注释真的非常之少，而且缺乏系统指导性的最佳实践，甚至连苹果系统内部对于图片方向的判断逻辑都出现严重的前后不一。不过通过这个问题，我们推想出了一个最佳实践，那就是只有在显示渲染的时候，我们才去做手动downsampling，对于encode来说，downsampling的操作是可以传入参数自动完成的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/27/Debug Universal Link/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/27/Debug Universal Link/" itemprop="url">Debug Universal Link</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-27T22:37:03+08:00">
                2020-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这片文章主要是记录一下几个月前发生的一件事，其中有些经验值得写一写。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一次我们的测试给我提了一个bug是说App间的跳转不生效了。我们的App是通过Universal Link进行跳转的，所以我第一时间先在我的手机检查了一下 Safari 的跳转和 <code>apple-app-site-association</code> 文件内容，发现都没有问题。当时就很困惑到底哪里出了问题，所以去社区看了看有没有类似的问题，发现了两个radar:</p>
<ul>
<li><a href="https://openradar.appspot.com/45201697" target="_blank" rel="noopener">rdar://45201697: iOS 12 cannot fetch AASA file within 5 minutes after rebooting the phone</a></li>
<li><a href="https://openradar.appspot.com/33893852" target="_blank" rel="noopener">rdar://33893852: Certain users fail to download apple-app-site-association when downloading the app</a></li>
</ul>
<p>看了一下基本都是下载 AASA 的问题，那问题来了，下载 AASA 文件的过程要怎么debug呢？</p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>看了一下网上的方案，大致上分为两种：</p>
<h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p>根据这个讨论 <a href="https://discussions.apple.com/thread/250111811#:~:text=swcd%20is%20the%20shared%20web,When%20swcd" target="_blank" rel="noopener">what is SWC Agent Database in keychain?</a> 我们可以了解到 AASA 文件的下载是在 swcd 这个进程进行的。所以我们可以打开 Console，用手机重新安装App，选择查看 swcd 的log来进行debug。</p>
<p>我尝试了这种方法，发现问题是出在测试的手机上有代理，导致 AASA 下载失败了。</p>
<p>然而，后来我发现还有一种更神秘的方案可以进行debug。</p>
<h3 id="Sysdiagnose"><a href="#Sysdiagnose" class="headerlink" title="Sysdiagnose"></a>Sysdiagnose</h3><p>苹果的工程师在去年曾经介绍了一种 debug universal link 的方式：<a href="https://twitter.com/grynspan/status/1136294209328041993" target="_blank" rel="noopener">Twitter</a>。结合 Sysdiagnose ，日志收集流程如下：</p>
<ol>
<li>复现问题</li>
<li>同时按下两个音量键和侧边键1秒左右，如果成功触发 Sysdiagnose，你会感受到一个震动</li>
<li>等待10分钟</li>
<li>在手机的log中找到 <code>sysdiagnose_YYYY.MM.DD_HH-MM-SS-XX…</code> 这样匹配你的时间的文件并发到你的设备上</li>
<li>打开其中的 <code>swcutil_show.txt</code> 你就能看到非常详细的 universal link 信息。</li>
</ol>
<p><img src="644ADED7-A50E-4BBF-99F4-D7AF976EBC20.png" alt=""></p>
<p>好吧，真的是非常详细了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了一些很tricky的东西。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/27/图片渲染优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/27/图片渲染优化/" itemprop="url">图片渲染优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-27T01:21:01+08:00">
                2020-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>图片渲染是iOS app中必不可少的一环，当我们在屏幕上展示一幅图片的时候，一个 workflow 应该是这样的：</p>
<ul>
<li>拿到图片的 Data buffer</li>
<li>decode 得到图片的 Image buffer</li>
<li>将 Image buffer 渲染到屏幕上</li>
</ul>
<p>这个流程看上去没有问题，但是有一点值得我们注意。假设我们要显示一张 2000 <em> 1000 的图片，在decode环节我们decode出来的 image buffer 的大小就会是 2000 </em> 1000 <em> 4 byte = 7.6MB，这里我们会发现 image buffer 的大小和图片的分辨率是正相关的，但有的时候，图片和最终展示在界面上的尺寸是不同的。比如这张 2000 </em> 1000 的图片，假如是展示在一个 200 * 100 的 view 上，那显然有很多像素信息是会被浪费掉的。</p>
<p>如何解决这个问题呢？</p>
<h2 id="Downsampling"><a href="#Downsampling" class="headerlink" title="Downsampling"></a>Downsampling</h2><p>我们的思路可能是说建立一个新的 workflow ：</p>
<ul>
<li>拿到图片的 Data buffer</li>
<li>根据显示区域的大小建立一个 thumbnail 区域</li>
<li>decode 图片的 Data buffer 到这个 thumbnail 区域，得到一个小一些的 Image buffer</li>
<li>将 Image buffer 渲染到屏幕上</li>
</ul>
<p>WWDC18-session219 详细介绍了如何去进行这样的 downsampling，同事值得注意的是我们可以将 downsampling 的过程放在后台线程进行，再将结果回调到主线程进行展示，这也很大程度上能缓解 CPU 的压力。</p>
<p><img src="219_hd_image_and_graphics_best_practices-0001.png" alt=""></p>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>别误会，这里的 rasterization 并不是 <code>CALayer</code> 的概念。我们在图片渲染上头疼的点在于图片像素尺寸和界面上展示的尺寸很可能是不同的。这里其实我们还会想到一种方案来解决：使用矢量图。</p>
<p>矢量图和位图不同，矢量图并不存储图片的像素信息，它是通过数学表达的方式通过点和曲线的连接来构成图形。图形层显示矢量图会进行 rasterization 来将矢量图信息转换成位图的信息并直接渲染到 frame buffer 上。</p>
<p>在 iOS 13 以前，我们使用矢量图的方案是通过在 image assets 添加PDF文件来实现。Xcode 会在编译期来进行 rasterization 将图片转换成位图（当然这样做也失去了矢量图的一些特性）。</p>
<p>在 iOS 13之后，我们可以通过私有库 <code>CoreSVG</code> 进行 SVG 的渲染，在未来，我们也有希望使用 <a href="https://svgwg.org/specs/svg-native/" target="_blank" rel="noopener">SVG Native</a> 来进行规范化的矢量图形渲染。</p>
<h2 id="Rendering-Speed"><a href="#Rendering-Speed" class="headerlink" title="Rendering Speed"></a>Rendering Speed</h2><p>通过上面的做法，我们基本已经避免了在渲染层面上浪费过多的内存的情况，那么我们如何再进一步去优化渲染速度呢？</p>
<p>从 iOS 10 开始， <code>UICollectionView</code> 就支持了通过 <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdatasourceprefetching" target="_blank" rel="noopener">UICollectionViewDataSourcePrefetching</a> 来通过预加载来异步获取数据的方案。我们可以通过预加载来提前在后台线程执行图片的获取和解码，在用户视角上提高渲染的速度。</p>
<p>还有一种方案也是通过提前解码来实现加速渲染的，那就是很多第三方库所使用的预解码技术。</p>
<p>在这之前我们先了解一下 <code>Core Animation</code> 的渲染原理。</p>
<p><img src="1*IVE7oJ666BYq8RtLq-Vs4Q.png" alt=""></p>
<p>用人话来说就是对于 <code>UIImageView</code> 来说，渲染流程是这样的：</p>
<ul>
<li>拿到 <code>UIImageView</code> 的 <code>layer.contents</code></li>
<li>从拿到的 <code>CGimage</code> decode 获取 image buffer</li>
<li>向GPU发送 Draw Calls</li>
<li>GPU进行渲染然后将结果展示在硬件上</li>
</ul>
<p>那么我们的优化方向就是如何让 render server 提前拿到 image buffer，这样就能加快渲染速度了。这里我们就要说说 <code>CGImage</code> 这个东西了。</p>
<h3 id="CGImage"><a href="#CGImage" class="headerlink" title="CGImage"></a>CGImage</h3><p>我们先看看 <code>CGImage</code> 的初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>?(width: <span class="type">Int</span>, </span><br><span class="line">height: <span class="type">Int</span>, </span><br><span class="line">bitsPerComponent: <span class="type">Int</span>, </span><br><span class="line">bitsPerPixel: <span class="type">Int</span>, </span><br><span class="line">bytesPerRow: <span class="type">Int</span>, </span><br><span class="line">space: <span class="type">CGColorSpace</span>, </span><br><span class="line">bitmapInfo: <span class="type">CGBitmapInfo</span>, </span><br><span class="line">provider: <span class="type">CGDataProvider</span>, </span><br><span class="line">decode: <span class="type">UnsafePointer</span>&lt;<span class="type">CGFloat</span>&gt;?, </span><br><span class="line">shouldInterpolate: <span class="type">Bool</span>, </span><br><span class="line">intent: <span class="type">CGColorRenderingIntent</span>)</span><br></pre></td></tr></table></figure>
<p>值得注意的是这个 provider，就是通过它来生成渲染所需要的 image buffer。经过研究，发现这里创建出 <code>CGImage</code> 但并没有进行 decode，而是在需要显示渲染的时候通过调用 <code>CGDataProviderCopyData</code> 来触发decode。所以我们这时列一下整个解码流程：</p>
<ul>
<li>获取 <code>layer.contents</code></li>
<li>获取 <code>image.cgImage</code></li>
<li><code>CGImageGetDataProvider</code> 获取data</li>
<li><code>CGDataProviderRetainBytePtr</code> 触发解码</li>
<li><code>CGDataProviderDirectCallbacks</code> 拿到数据</li>
<li>ImageIO进行解码拿到 image buffer</li>
</ul>
<p>了解了整个流程我们就知道了 iOS 系统的方案在生成 <code>CGImage</code> 的时候并没有创建完整的 image buffer ，而是在渲染的时候进行处理。那我们优化的方向就是用空间换时间，如果能在生成 <code>CGImage</code> 生成的时候直接把 image buffer 创建好，那渲染就会快很多了。</p>
<p>主流图片库的做法也很简单，通过<code>CGContextDrawImage</code> 绘制一遍生成出来的 <code>CGImage</code> 就可以了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲述了三种图片渲染上优化的方向，希望可以和对图片渲染有兴趣的朋友多多交流。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/30/Haskell/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/30/Haskell/" itemprop="url">Haskell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-30T10:57:01+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.cis.upenn.edu/~cis194/spring13/images/haskell-logo-small.png" alt="Haskell"></p>
<blockquote>
<p>Haskell is a <em>lazy, functional</em> programming language created in the late 1980’s by a committee of academics. </p>
</blockquote>
<ul>
<li><strong>functional</strong>: functions are <em>first-class</em>, centered around <em>evaluating expressions</em> rather than <em>executing instructions</em>.</li>
<li><strong>pure</strong>: <em>immutable</em>, no <em>side effects</em>, calling the same function with the same arguments results in the same output every time.</li>
<li><strong>lazy</strong>: <em>call-by-need</em>, expressions are <em>not evaluated until their results are actually needed</em>.Alone with <em>Memoization</em></li>
<li><strong>statically typed</strong>: as Swift.Every Haskell expression has a type, and types are all checked at <em>compile-time</em>.</li>
<li><strong>abstraction</strong>: <em>parametric polymorphism</em>, <em>higher-order functions</em></li>
<li><strong>wholemeal programming</strong>: </li>
</ul>
<blockquote>
<p>“Functional languages excel at wholemeal programming, a term coined by Geraint Jones. Wholemeal programming means to think big: work with an entire list, rather than a sequence of elements; develop a solution space, rather than an individual solution; imagine a graph, rather than a single path. The wholemeal approach often offers new insights or provides new perspectives on a given problem. It is nicely complemented by the idea of projective programming: first solve a more general problem, then extract the interesting bits and pieces by transforming the general program into more specialised ones.” — Ralf Hinze</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; int acc = 0;</span><br><span class="line">for ( int i = 0; i &lt; lst.length; i++ ) &#123;</span><br><span class="line">  acc = acc + 3 * lst[i];</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sum (map (3*) lst)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Lazy-evaluation"><a href="#Lazy-evaluation" class="headerlink" title="Lazy evaluation"></a>Lazy evaluation</h2><h4 id="Strict-evaluation"><a href="#Strict-evaluation" class="headerlink" title="Strict evaluation"></a>Strict evaluation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f (release_monkeys(), increment_counter())</span><br></pre></td></tr></table></figure>
<p>If the releasing of monkeys and incrementing of the counter could independently happen, or not, in either order, depending on whether f happens to use their results, it would be extremely confusing. When such <em>“side effects”</em> are allowed, strict evaluation is really what you want.</p>
<h4 id="Side-effects-and-purity"><a href="#Side-effects-and-purity" class="headerlink" title="Side effects and purity"></a>Side effects and purity</h4><p>By “side effect” we mean anything that <em>causes evaluation of an expression to interact with something outside itself</em>.The root issue is that such outside interactions are time-sensitive.</p>
<ul>
<li>No global variable</li>
<li>No output to screen</li>
<li>No reading from a file or the network</li>
</ul>
<p>WTF……</p>
<p>The solution is IO monad.</p>
<h4 id="Consequences"><a href="#Consequences" class="headerlink" title="Consequences"></a>Consequences</h4><ul>
<li>Purity</li>
<li>Tricky space usage</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- Standard library function foldl, provided for reference</span><br><span class="line">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line">foldl _ z []     = z</span><br><span class="line">foldl f z (x:xs) = foldl f (f z x) xs</span><br><span class="line"></span><br><span class="line">foldl (+) 0 [1,2,3]</span><br><span class="line">= foldl (+) (0+1) [2,3]</span><br><span class="line">= foldl (+) ((0+1)+2) [3]</span><br><span class="line">= foldl (+) (((0+1)+2)+3) []</span><br><span class="line">= (((0+1)+2)+3)</span><br><span class="line">= ((1+2)+3)</span><br><span class="line">= (3+3)</span><br><span class="line">= 6</span><br><span class="line"></span><br><span class="line">foldl&apos; (+) 0 [1,2,3]</span><br><span class="line">= foldl&apos; (+) (0+1) [2,3]</span><br><span class="line">= foldl&apos; (+) 1 [2,3]</span><br><span class="line">= foldl&apos; (+) (1+2) [3]</span><br><span class="line">= foldl&apos; (+) 3 [3]</span><br><span class="line">= foldl&apos; (+) (3+3) []</span><br><span class="line">= foldl&apos; (+) 6 []</span><br><span class="line">= 6</span><br></pre></td></tr></table></figure>
<p>Consider if there is a very long list, it leads to stack overflow.</p>
<ul>
<li>Short-circuiting operators</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span><br><span class="line">True  &amp;&amp; x = x</span><br><span class="line">False &amp;&amp; _ = False</span><br></pre></td></tr></table></figure>
<ul>
<li>Infinite data structures</li>
<li>Pipelining/wholemeal programming<ul>
<li>due to laziness, each stage of the pipeline can operate in lockstep, only generating each bit of the result as it is demanded by the next stage in the pipeline.</li>
</ul>
</li>
<li>Thunk.</li>
<li>Confilct with parallel computing.</li>
</ul>
<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><ul>
<li>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</li>
<li>treeMap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b</li>
<li>maybeMap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</li>
</ul>
<p>why not</p>
<p><code>thingMap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p>Since f is type variable, we can make a type class, which is traditionally called <strong>Functor</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Functor f where</span><br><span class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  </span><br><span class="line">(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br><span class="line">  </span><br><span class="line">instance Functor [] where</span><br><span class="line">  fmap _ []     = []</span><br><span class="line">  fmap f (x:xs) = f x : fmap f xs</span><br><span class="line">  </span><br><span class="line">instance Functor Maybe where</span><br><span class="line">  fmap _ Nothing  = Nothing</span><br><span class="line">  fmap h (Just a) = Just (h a)</span><br></pre></td></tr></table></figure>
<h2 id="Applicative-functors"><a href="#Applicative-functors" class="headerlink" title="Applicative functors"></a>Applicative functors</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name = String</span><br><span class="line"></span><br><span class="line">data Employee = Employee &#123; name    :: Name</span><br><span class="line">                         , phone   :: String &#125;</span><br></pre></td></tr></table></figure>
<p>So Employee is </p>
<p><code>Employee :: Name -&gt; String -&gt; Employee</code></p>
<p>However, sometimes we want this:</p>
<p><code>(Name -&gt; String -&gt; Employee) -&gt; Maybe Name -&gt; Maybe String -&gt; Maybe Employee</code></p>
<p>and why not provide this as well:</p>
<p><code>Name -&gt; String -&gt; Employee) -&gt; [Name] -&gt; [String] -&gt; [Employee]</code></p>
<p>Seems wec can use <code>fmap</code> to do this job, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Functor f where</span><br><span class="line">  fmap2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">  </span><br><span class="line">fmap2 :: Functor f =&gt; (a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</span><br><span class="line">fmap2 h fa fb = ???</span><br><span class="line"></span><br><span class="line">h :: a -&gt; (b -&gt; c)</span><br><span class="line">fmap h :: fa -&gt; f(b -&gt; c)</span><br><span class="line">fmap h fa :: f(b -&gt; c)</span><br></pre></td></tr></table></figure>
<p>The reason why we cannot implement fmap2 is <code>fmap h fa :: f (b -&gt; c)</code>, and we cannot handle <code>f (b -&gt; c)</code> with <code>f b</code></p>
<p>So it’s time to introduce <em>Applicative</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Functor f =&gt; Applicative f where</span><br><span class="line">  pure  :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">liftA2 h fa fb = (h `fmap` fa) &lt;*&gt; fb</span><br><span class="line"></span><br><span class="line">liftA3 :: Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d</span><br><span class="line">liftA3 h fa fb fc = ((h &lt;$&gt; fa) &lt;*&gt; fb) &lt;*&gt; fc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Law for <code>Applicative</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; f `fmap` x === pure f &lt;*&gt; x</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h2><p>From <em>functor</em> and <em>applicative</em>, we can see computations with a fixed structure.</p>
<p>However, sometimes we want to be able to decide what to do based on some intermediate results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtype Parser a = Parser &#123; runParser :: String -&gt; Maybe (a, String) &#125;</span><br></pre></td></tr></table></figure>
<p>Suppose we are trying to parse a file containing a sequence of numbers, like this:</p>
<blockquote>
<p>4 78 19 3 44 3 1 7 5 2 3 2</p>
</blockquote>
<p>So the example above could be broken up into groups like this:</p>
<blockquote>
<p>78 19 3 44   – first group<br>1 7 5        – second group<br>3 2          – third group</p>
</blockquote>
<p>So what we need is some thing like this:<br><code>parseFile :: Parser [[Int]]</code> </p>
<p><em>Applicative</em> gives us no way to decide what to do next based on previous results: we must decide in advance what parsing operations we are going to run, before we see the results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Monad m where</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line"></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"></span><br><span class="line">  (&gt;&gt;)  :: m a -&gt; m b -&gt; m b</span><br><span class="line">  m1 &gt;&gt; m2 = m1 &gt;&gt;= \_ -&gt; m2</span><br></pre></td></tr></table></figure>
<p><code>m</code> refer to <em>monads</em> and <code>m a</code> refer to <em>mobits</em>. A mobit of type <code>m</code> a represents a computation which results in a value (or several values, or no values) of type <code>a</code>.</p>
<p>A function which will choose the next computation to run based on the result(s) of the first computation.</p>
<p>So all (&gt;&gt;=) really does is put together two mobits to produce a larger one, which first runs one and then the other, returning the result of the second one. </p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><a href="http://www.seas.upenn.edu/~cis194/spring13/lectures.html" target="_blank" rel="noopener">CIS 194</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Junjie Lu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/junjielu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/lujunjie1008" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junjie Lu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
