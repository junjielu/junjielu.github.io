<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.jpg?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Ballad">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ballad">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Ballad">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Ballad</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ballad</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-snippets">
          <a href="/develop/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-code"></i> <br>
            
            片段
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/15/structuredconcurrency/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/15/structuredconcurrency/" itemprop="url">Structured concurrency</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-15T13:05:50+08:00">
                2020-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>async</code>/<code>await</code>是用于编写自然、高效的异步代码的语言机制。异步函数（通过<code>async</code>引入）可以在任意挂起点上（标记为<code>await</code>）放弃执行它们的线程，这对于构建高并发系统是必要的。</p>
<p>然而，<code>async</code>/<code>await</code>提议本身并没有引入并发性：如果你忽略异步函数中的挂起点，它将以与同步函数基本相同的方式执行。这个提议引入了对Swift中结构化并发的支持，使异步代码的并发执行具有一个符合直觉、可预测和高效实现的模型。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>举一个做饭的例子，这里行为是异步的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chopVegetables</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Vegetable</span>] &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">marinateMeat</span><span class="params">()</span></span> async -&gt; <span class="type">Meat</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preheatOven</span><span class="params">(temperature: Double)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Oven</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDinner</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Meal</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> veggies = await <span class="keyword">try</span> chopVegetables()</span><br><span class="line">  <span class="keyword">let</span> meat = await marinateMeat()</span><br><span class="line">  <span class="keyword">let</span> oven = await <span class="keyword">try</span> preheatOven(temperature: <span class="number">350</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dish = <span class="type">Dish</span>(ingredients: [veggies, meat])</span><br><span class="line">  <span class="keyword">return</span> await <span class="keyword">try</span> oven.cook(dish, duration: .hours(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的晚餐准备过程中，每一步都是一个异步操作，所以会有很多的挂起点。在等待<code>chopVegetables</code>的过程中，<code>makeDinner</code>不会阻塞线程：它会挂起，直到<code>chopVegetables</code>返回，然后继续往下走。以此类推，晚餐的准备工作可能处于不同的阶段，大多数会挂起，直到目前的步骤完成。</p>
<p>然而，即使我们的准备晚餐是异步的，但仍然是顺序的。它会等到蔬菜被切碎后再开始腌肉，然后再次等到肉准备好了再预热烤箱。当晚餐准备好的时候，顾客会感到非常饥饿。</p>
<p>为了加快准备晚餐的速度，我们需要同时执行其中的一些步骤。为了做到这一点，我们可以将准备晚餐分解为可以并行发生的不同任务。蔬菜可以在肉类腌制和烤箱预热的同时切碎。有时任务之间会有依赖性:一旦蔬菜和肉准备好了，我们可以把它们放在一个盘子里，但直到烤箱热起来我们才能把那个盘子放进烤箱。所有这些任务都是做饭这一更大任务的一部分。当所有这些任务完成后，晚餐就开始了。</p>
<p>此提议旨在提供必要的工具，以将工作分解为可以并发运行的更小的任务，允许任务彼此等待完成，并有效地管理任务的总体进度。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们的方案遵循结构化并发的原则。所有异步函数都作为异步任务的一部分运行。任务可以方便地使子任务并发地执行工作。这就创建了任务的层次结构，信息可以方便地在层次结构中上下流动，从而方便了对事情的整体管理。</p>
<h3 id="子任务"><a href="#子任务" class="headerlink" title="子任务"></a>子任务</h3><p>这个提议引入了一个简单的方法通过<code>async let</code>来创建子任务：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDinner</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Meal</span> &#123;</span><br><span class="line">  async <span class="keyword">let</span> veggies = <span class="keyword">try</span> chopVegetables()</span><br><span class="line">  async <span class="keyword">let</span> meat = marinateMeat()</span><br><span class="line">  async <span class="keyword">let</span> oven = <span class="keyword">try</span> preheatOven(temperature: <span class="number">350</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dish = <span class="type">Dish</span>(ingredients: await [veggies, meat])</span><br><span class="line">  <span class="keyword">return</span> await <span class="keyword">try</span> oven.cook(dish, duration: .hours(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>async let</code>与<code>let</code>十分相似，它定义了一个局部常量，该常量由赋值操作右侧的表达式初始化。但是，不同之处在于前者的初始化表达式是在单独的、并发执行的子任务中求值的。在任务完成时，子任务将初始化变量并返回。</p>
<p>由于函数的主体与其子任务并发执行，因此<code>makeDinner</code>可能会在生成<code>async let</code>的值之前到达需要该值的位置。为了说清楚这一点，读取由<code>async let</code>定义的变量被视为一个挂起点，因此必须标记为<code>await</code>。该任务将暂停，直到子任务完成变量的初始化，然后继续执行。</p>
<p>可以将<code>async let</code>看作是引入了一个隐藏的<code>future</code>，它是在声明<code>async let</code>时创建的，它的值是在<code>await</code>时取回的。从这个意义上说，<code>async let</code>是<code>future</code>的语法糖。</p>
<p>然而，在提出的结构化并发模型中，子任务有意地比一般用途的<code>future</code>受到更多的限制。与标准的<code>future</code>实现不同，子任务不会存在于创建它的上下文之外。在上下文结束时，子任务必须已经完成，否则将隐式取消。这种结构既可以更容易地推断在给定范围内执行的并发任务，也可以为编译器和运行时提供大量的优化机会。</p>
<p>让我们回到我们的例子。注意，如果出现了一些意外，<code>chopVegetables()</code>函数可能会抛出一个错误。抛出的错误结束了切菜的子任务。然后，正如预期的那样，错误将被传播到<code>makeDinner()</code>函数之外。在退出<code>makeDinner()</code>函数体时，任何尚未完成的子任务（腌制肉或预热烤箱，可能两者都有）将被自动取消。</p>
<h3 id="使用任务组组织子任务"><a href="#使用任务组组织子任务" class="headerlink" title="使用任务组组织子任务"></a>使用任务组组织子任务</h3><p>使用<code>async let</code>的结构可以很容易地创建一系列子任务并将它们与变量关联起来。但是，这个构造很难满足动态化的工作需求，在动态化的工作中，我们不知道需要创建的子任务的数量，因为它取决于数据结构的规模。为此，我们需要一个更动态的结构：任务组。</p>
<p>任务组定义了一个范围，可以在其中以编程方式创建新的子任务。与所有子任务一样，任务组作用域内的子任务必须在作用域退出时完成。这相当于一个正常的函数作用域在所有<code>async let</code>变量退出作用域之前强制执行等待，但是对于动态添加的子任务，<code>await</code>在任务组作用域退出时变成隐式的了。对于未完成的非<code>await</code>任务，各种行为变体很可能源于调用方配置。任务组还提供了处理子任务结果的程序，例如，通过等待直到下一个子任务完成。</p>
<p>为了进一步扩展我们的示例，让我们考虑<code>chopVegetables()</code>操作，该操作生成一个<code>Vegetable</code>数组。如果我们有足够的厨师来把每种蔬菜分开，那就可以更快地切蔬菜。</p>
<p>让我们从<code>chopVegetables()</code>的顺序版本开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Sequentially chop the vegetables.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chopVegetables</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Vegetable</span>] &#123;</span><br><span class="line">  <span class="keyword">var</span> veggies: [<span class="type">Vegetable</span>] = gatherRawVeggies()</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> veggies.<span class="built_in">indices</span> &#123;</span><br><span class="line">    veggies[i] = await <span class="keyword">try</span> veggies[i].chopped()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> veggies</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环中引入<code>async let</code>不会产生任何有意义的并发性，因为每个<code>async let</code>都需要在循环的下一个迭代开始之前完成。为了以编程方式创建子任务，我们通过<code>Task.withGroup</code>引入了一个新的任务组上下文：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Sequentially chop the vegetables.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chopVegetables</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Vegetable</span>] &#123;</span><br><span class="line">  <span class="comment">// Create a task group where each task produces (Int, Vegetable).</span></span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withGroup(resultType: (<span class="type">Int</span>, <span class="type">Vegetable</span>).<span class="keyword">self</span>) &#123; group <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">var</span> veggies: [<span class="type">Vegetable</span>] = gatherRawVeggies()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create a new child task for each vegetable that needs to be </span></span><br><span class="line">    <span class="comment">// chopped.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rawVeggies.<span class="built_in">indices</span> &#123;</span><br><span class="line">      await <span class="keyword">try</span> group.add &#123; </span><br><span class="line">        (i, veggies[i].chopped())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for all of the chopping to complete, slotting each result</span></span><br><span class="line">    <span class="comment">// into its place in the array as it becomes available.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> (index, choppedVeggie) = await <span class="keyword">try</span> group.next() &#123;</span><br><span class="line">      veggies[index] = choppedVeggie</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> veggies</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Task.withGroup(resultType:body:)</code>函数引入了一个新的上下文，可以在其中创建子任务（通过<code>add(_:)</code>函数）。<code>next()</code>函数会等待下一个子任务完成，并提供子任务的返回值。在我们上面的例子中，每个子任务都携带索引和切好的蔬菜。</p>
<p>就像通过<code>async let</code>创建的子任务一样，如果传给<code>Task.withGroup</code>的闭包在没有完成所有子任务前退出了，那么剩余的子任务都将自动取消。</p>
<h3 id="分离任务"><a href="#分离任务" class="headerlink" title="分离任务"></a>分离任务</h3><p>到目前为止，我们创建的每个任务都是子任务，其生命周期受到上下文的限制。这不允许创建超过当前上下文的新任务。</p>
<p><code>runDetached</code>操作创建一个新任务。它接受一个闭包，该闭包将作为任务的主体执行。在这里，我们创建了一个新的分离任务来做晚餐：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dinnerHandle = <span class="type">Task</span>.runDetached &#123;</span><br><span class="line">  await makeDinner()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runDetached</code>的返回是一个<code>handle</code>，可以在操作完成时（通过<code>get()</code>）返回操作的结果，或者在不再需要结果时（通过<code>cancel()</code>取消任务）使用它。与子任务不同，分离任务即使没有剩余的任务处理，也不会被取消，因此<code>runDetached</code>适用于不关心完成情况的操作。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="结构化的并发"><a href="#结构化的并发" class="headerlink" title="结构化的并发"></a>结构化的并发</h3><p>任何并发系统都必须提供某些基本工具。必须有某种方法来创建一个与现有线程并发运行的新线程。还必须有某种方法让一个线程挂起，直到另一个线程发出继续执行的信号。这些都是强大的工具，您可以使用它们编写非常复杂的系统。但它们也是非常原始的工具：它们很少做情况假设，但反过来它们也不会提供太多的支持。</p>
<p>假设有一个函数在CPU上做大量的工作。我们希望通过将工作分到两个核中来优化；因此，现在该函数会创建一个新线程，在每个线程中执行一半的工作，然后让其原始线程等待新线程完成。（在更现代的系统中，该函数可能会向全局线程池添加一个任务，但基本概念是相同的。）这两个线程所做的工作之间存在联系，但系统并不知道它。这加大了解决系统性问题的难度。</p>
<p>例如，假设一个高优先级操作需要上面的函数加急完成。该操作可能会升级第一个线程的优先级，但实际上它应该同时升级两个线程。在最好的情况下，它不会升级第二个线程，直到第一个线程开始等待它的完成。狭义地解决这个问题相对容易，可以让函数注册第二个应该升级的线程。但这将会成为一个通解，因为每个想要使用并发性的函数都可能重复这个行为。</p>
<p>结构化并发通过要求程序员将并发组织成任务和子任务来解决这个问题。这些任务成为并发的主要单元，而不是像线程这样的底层概念。以这种方式构造并发允许信息自然地在任务层次结构中上下流动，否则在每个层级的抽象和每个线程的转换上都需要仔细编写代码。这反过来又让相对轻松地解决一些高级问题成为可能。</p>
<p>举一些例子：</p>
<ul>
<li>通常我们都希望限制在一个任务上花费的时间。一些api通过传入超时时间来支持这一点，但是要在每个抽象级别正确地传递超时时间需要做很多工作。这一点尤其重要，因为终端程序员通常希望将超时写成持续时间（比如20ms)，但正确处理的库在内部中传递的会是截止时间（比如now + 20ms）。在结构化并发下，可以在任务上设置截止时间，并自然地传递到任意级别的API，包括子任务。</li>
<li>类似地，有时我们希望能够取消正在执行的任务。支持此功能的异步接口一般来说会返回一个token，并提供某种<code>cancel()</code>方法来实现。这极大地复杂化了API的设计，因此通常我们不这么做。此外，传递token，或者组合token以取消所有正在执行的任务，会给程序带来重大的工程挑战。在结构化并发下，取消通过api自然地下发到子任务，而api可以简单地通过设置处理代码来响应取消。</li>
<li>图形用户界面通常依赖于任务优先级来确保及时刷新和响应事件。在结构化并发下，子任务自然继承父任务的优先级。此外，当高优先级任务等待低优先级任务完成时，低优先级任务及其所有子任务的优先级都可以提升，而且即使任务被暂时挂起，这种优先级也会可靠地持续存在。</li>
<li>许多系统希望为操作维护它们自己的上下文信息，而不需要将其传递到每个抽象级别，例如记录当前服务的连接信息的服务器。结构化并发允许这种特性作为一种“局部任务存储”自然地通过异步操作传播，这种存储可以被子任务获取。</li>
<li>依赖队列的系统通常容易受到队列泛滥的影响，即队列接受的工作量超过了它实际能够处理的工作量。这通常可以通过引入“反压”来解决：队列停止接受新工作，试图将工作安排到队列中的系统会做出响应，停止接受新工作。<code>Actor</code>系统通常会破坏这种情况，因为在调度器级别上很难拒绝向<code>Actor</code>队列添加工作，因为这样做可能会资源遗漏或阻止操作完成，从而永久性地破坏系统的稳定。结构化并发提供了一种有限的、协作的解决方案，它允许系统在遇到困难时向任务层次结构的上层传递信息，潜在地允许父任务停止或减缓类似的新工作的创建。</li>
</ul>
<p>这个提议并没有为所有这些问题提出解决方案，但是我们早期的研究可以给出一些期待。</p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>任务是系统中并发的基本单位。每个异步函数都在一个任务中执行。换句话说，任务对应异步函数，就像线程对应同步函数一样。那么：</p>
<ul>
<li>所有的异步函数都作为任务的一部分来运行</li>
<li>一个任务一次只执行一个函数，所以单个任务是不并发的</li>
<li>当函数执行<code>async</code>的调用，被调用的函数依旧是作为同一任务的一部分运行（调用方等待它的返回）</li>
<li>同样，当一个函数从一个<code>async</code>调用返回时，调用方会在同一任务上继续执行</li>
</ul>
<p>同步函数不一定作为任务的一部分运行。</p>
<p>Swift假设存在一个底层线程系统。任务由系统调度在这些系统线程上运行。任务不需要来自底层线程系统的特殊调度支持，尽管一个好的调度程序可以利用Swift任务调度的一些有趣特性。</p>
<p>任务可以处于以下三种状态之一：</p>
<ul>
<li><strong>挂起状态</strong>，可能还有更多工作要做，但至少现在并没有在运行。<ul>
<li>它可能是<strong>可调度</strong>状态，表示它已经准备好运行，只是在等待系统指派线程开始执行它。</li>
<li>也可能是<strong>等待</strong>状态，可能还需要一些外部事务来让它变成<strong>可调度</strong>状态</li>
</ul>
</li>
<li><strong>运行中</strong>，它正运行在一个线程上。<ul>
<li>它将一直运行，直到它从初始函数返回或到达一个挂起点为止。在一个挂起点上时，如果它的执行只需要改变<code>actor</code>，那么它可能立即成为<strong>可调度</strong>状态。</li>
</ul>
</li>
<li><strong>完成状态</strong>，没有工作需要做了，所以也不会进入别的状态了。<ul>
<li>代码可以通过各种方式等待任务完成，最明显的就是使用<code>await</code>。</li>
</ul>
</li>
</ul>
<p>我们讨论任务和异步函数执行的方式要比同步函数复杂得多。异步函数作为任务的一部分运行。如果任务正在运行，则它及其当前执行的函数也在一个线程上运行。</p>
<p>注意，当一个异步函数调用另一个异步函数时，我们说调用函数被挂起，但这并不意味着整个任务被挂起。从函数的角度来看，它被挂起，等待调用返回。从任务的角度来看，它可能在被调用方中继续运行，或者被挂起，以便转移到一个不同的上下文中。</p>
<p>任务服务于三个高层次目的：</p>
<ul>
<li>它们携带调度信息，比如任务的优先级。</li>
<li>它们可以被当作一个操作，可以取消、查询或更改。</li>
<li>它们可以携带用户提供的局部任务数据。</li>
</ul>
<p>在底层层次上，该任务允许实现优化本地内存的分配，比如异步函数上下文。它还允许动态工具、崩溃报告器和调试器发现函数是如何使用的。</p>
<h3 id="子任务-1"><a href="#子任务-1" class="headerlink" title="子任务"></a>子任务</h3><p>异步函数可以创建子任务。子任务继承父任务的一些结构，包括其优先级，且可以与父任务并发运行。但是，这种并发性是有限制的：创建子任务的函数必须等待子任务结束后才能返回。这种结构意味着函数可以推断出为当前任务所做的所有工作，预期取消当前任务的影响，等等。它还大大提高了生成子任务的效率。</p>
<p>当然，一个函数的任务本身可能是另一个任务的子任务，它的父任务可能有其他的子任务；函数无法对这些进行推理。但是应用于整个任务树的这种设计的特性，比如取消，只向下应用，而不会在任务层次结构中向上传播，因此子树仍然可以被静态推断。如果子任务没有限定的持续时长，可以任意地超过父任务，那么在这些特征下的任务行为就不容易理解。</p>
<h3 id="部分任务"><a href="#部分任务" class="headerlink" title="部分任务"></a>部分任务</h3><p>任务的执行可以看作是任务运行阶段的演替，每个阶段都在一个挂起点结束，或者最终在任务完成时结束。这些阶段称为部分任务。部分任务是系统中可调度工作的基本单元。它们也是异步函数与底层同步世界交互的原语。在大多数情况下，程序员不应该直接处理部分任务，除非他们正在实现自定义执行器。</p>
<h3 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h3><p>执行程序是一种服务，它接受部分任务的提交，并安排某个线程运行它们。系统假设执行程序是可靠的，并且永远不会失败地运行部分任务。</p>
<p>当前运行的异步函数总是知道运行它的执行程序。这允许函数在调用同一执行程序时避免不必要的挂起，并且允许函数在它开始执行的同一执行程序上继续执行。</p>
<p>如果提交给执行程序的部分任务永远不会并发运行，则称为独占执行程序。（具体来说，部分任务必须完全按照happens-before关系排序：给定任何两个已提交并运行的任务，其中一个必须在另一个开始之前结束。）执行程序不需要按照任务提交的顺序运行部分任务；实际上，它们通常应该尊重任务优先级而不是提交顺序。</p>
<p>Swift提供了一个默认的执行程序实现，但是<code>actor</code>类和全局<code>actor</code>都可以禁用这个实现，并提供它们自己的实现。</p>
<p>通常终端程序员不需要直接与执行程序交互，而是通过调用恰好使用执行程序的异步函数和actor和函数来隐式地使用它们。</p>
<h3 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h3><p>一个任务与特定的<code>Task.Priority</code>相关联。</p>
<p>任务优先级可以告知执行程序如何以及何时调度提交给它的任务。执行程序可以利用优先级信息首先尝试运行优先级较高的任务，然后继续为优先级较低的任务提供服务。它还可以使用优先级信息来影响线程的优先级。</p>
<p>如何处理优先级的确切语义留给每个平台和特定的执行程序实现。</p>
<p>子任务自动继承父任务的优先级。分离任务不继承优先级（或任何其他信息），因为它们在语义上没有父任务。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">currentPriority</span><span class="params">()</span></span> async -&gt; <span class="type">Priority</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Priority</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `<span class="keyword">default</span>`: <span class="type">Task</span>.<span class="type">Priority</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TODO：定义任务优先级的细节；它很可能是一个类似于<code>Darwin Dispatch</code>的<code>QoS</code>的概念;请记住，在其他平台上（比如服务器端的Linux系统），优先级并不是那么重要。</p>
</blockquote>
<p>任务的优先级是在启动顶层任务时通过传递给<code>Task.runDetached(priority:operation:)</code>来设置的。任务的子任务将继承这个优先级。</p>
<p>任务的优先级不一定与其执行程序的优先级匹配。例如，苹果平台上的UI线程是高优先级执行程序；提交给它的任何任务都将在其在线程上的时间内以高优先级运行。这有助于确保UI线程在稍后提交高优先级的工作时可用。这并不影响任务的正式优先级。</p>
<h3 id="优先级提升"><a href="#优先级提升" class="headerlink" title="优先级提升"></a>优先级提升</h3><p>在某些情况下，任务的优先级必须提升，以避免优先级反转问题：</p>
<ul>
<li>如果任务是作为<code>actor</code>运行，并且有更高优先级任务在<code>actor</code>上排队，则该任务可以临时以高优先级任务的优先级运行。这并不影响子任务或<code>Task.currentPriority()</code>；它是运行任务的线程的属性，而不是任务本身。</li>
<li>如果一个任务是通过<code>Task.Handle</code>创建的。当高优先级任务调用<code>await try handle.get()</code>时，该任务的优先级将永久性提升，以匹配高优先级任务。这确实会影响子任务和<code>Task.currentPriority()</code>。</li>
</ul>
<h3 id="取消机制"><a href="#取消机制" class="headerlink" title="取消机制"></a>取消机制</h3><p>任何具有对任务或其父任务引用的上下文都可以异步取消任务。可以通过在任务上调用<code>cancel()</code>显式地触发取消。取消也可以自动触发，例如，当父任务在未等待的子任务的作用域之外抛出错误时（例如<code>async let</code>）。</p>
<p>取消在已取消任务中的效果是完全协作和同步的。也就是说，取消没有任何影响，除非有东西会依赖取消。通常，大多数依赖取消的函数通过抛出<code>CancellationError()</code>来报告取消；因此，它们必须是抛出函数，对它们的调用必须用某种形式的<code>try</code>进行修饰。因此，取消不会在异步函数中引入额外的控制流路径；您总是可以查看一个函数，并查看取消可以发生的地方。与其他抛出的错误一样，可以使用<code>defer</code>在取消后有效地进行资源清理。</p>
<p>因此，一般的预期是，异步函数应该尝试通过迅速抛出或返回来响应取消。在大多数函数中，依赖于可以等待很长时间的低层函数（例如，I/O函数或<code>Task.Handle.get()</code>）来检查取消和提前终止应该足够了。执行大量同步计算的函数可能希望定期显式地检查是否取消。</p>
<p>取消会立即触发两个效果：</p>
<ul>
<li>会在任务中设置一个标志，标志该任务已被取消；一旦设置了这个标志，它就不会被清空了。作为任务的一部分同步运行的操作可以检查此标志，通常预期会抛出<code>CancellationError</code>的错误。</li>
<li>注册在任务上的取消处理操作会立即执行。</li>
</ul>
<p>我们可以用前面看到的<code>chopVegetables()</code>函数的一个版本来演示取消操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chopVegetables</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Vegetable</span>] &#123;</span><br><span class="line">  async <span class="keyword">let</span> carrot = <span class="keyword">try</span> chop(<span class="type">Carrot</span>()) <span class="comment">// (1) throws UnfortunateAccidentWithKnifeError()!</span></span><br><span class="line">  async <span class="keyword">let</span> onion = <span class="keyword">try</span> chop(<span class="type">Onion</span>()) <span class="comment">// (2)</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> await <span class="keyword">try</span> [carrot, onion] <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一行，我们开启了一个子任务：切胡萝卜。假设这个对<code>chop</code>函数的调用抛出了一个错误。因为这是异步的，所以在<code>chopVegetables</code>中不会立即观察到错误，我们继续启动第二个子任务来切洋葱。在第三行中，我们<code>await</code>切胡萝卜和切洋葱的任务，这将导致我们抛出从<code>chop</code>中抛出的错误。因为我们不处理这个错误，所以我们在没有等待切洋葱任务完成的情况下就退出了作用域。这会导致自动取消该任务。由于取消是协作性的，而且结构化并发不允许子任务比父任务持续更久，所以在切断洋葱的任务实际完成之前，控制流实际上不会返回；它返回或抛出的任何值都将被丢弃。</p>
<p>如上所述，取消对任务的影响是同步和协作的。执行大量同步计算的函数可能希望显式地检查是否可以取消。它们可以通过检查任务的取消状态来实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chop</span><span class="params">(<span class="number">_</span> vegetable: Vegetable)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Vegetable</span> &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.checkCancellation() <span class="comment">// automatically throws `CancellationError`</span></span><br><span class="line">  <span class="comment">// chop chop chop ...</span></span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">guard</span> await !<span class="type">Task</span>.isCancelled() <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Canceled mid-way through chopping of \(vegetable)!"</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">CancellationError</span>() </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// chop some more, chop chop chop ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意，关于取消原因的信息没有传递给任务。一个任务可能由于许多原因被取消，并且在最初的取消之后可能会产生其他的原因（例如，如果任务不能立即退出，它可能会传递一个截止日期）。取消的目标是允许以轻量级的方式取消任务，而不是作为任务间通信的辅助方法。</p>
<h3 id="通过截止日期取消"><a href="#通过截止日期取消" class="headerlink" title="通过截止日期取消"></a>通过截止日期取消</h3><p>取消的一个非常常见的用例是当任务消耗了太长的时间以致任务被取消。这个提议引入了截止日期的概念，并使它们能够在超过截止日期时使任务自发取消。</p>
<p>我们有意使用截止日期（“时间点”）而不是超时（“持续时间”）。这是因为截止日期能被正确处理：使用超时很容易出现错误，即由于重用了超时，而不是根据已经过去的时间进行调整，从而意外地延长了截止日期。为了方便，我们允许代码在设置截止日期时使用相对超时；这将立即转化为一个绝对的截止日期。</p>
<p>为了进一步分析截止日期的语义，让我们用截止日期来扩展我们的晚餐准备例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeDinnerWithDeadline</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Meal</span> &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withDeadline(<span class="keyword">in</span>: .hours(<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">// intentionally wait until the vegetables have been chopped before starting any child tasks</span></span><br><span class="line">    <span class="keyword">let</span> veggies = await <span class="keyword">try</span> chopVegetables()</span><br><span class="line">    async <span class="keyword">let</span> meat = <span class="type">Task</span>.withDeadline(<span class="keyword">in</span>: .minutes(<span class="number">30</span>)) &#123;</span><br><span class="line">      marinateMeat()</span><br><span class="line">    &#125;</span><br><span class="line">    async <span class="keyword">let</span> oven = <span class="keyword">try</span> preheatOven(temperature: <span class="number">350</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> dish = <span class="type">Dish</span>(ingredients: await [veggies, meat])</span><br><span class="line">    <span class="keyword">return</span> await <span class="keyword">try</span> oven.cook(dish, duration: .hours(<span class="number">3</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cook</span><span class="params">(<span class="number">_</span> dish: Dish, duration: Duration)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Meal</span> &#123;</span><br><span class="line">  await <span class="keyword">try</span> checkCancellation()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们设置了两个截止日期。第一个截止日期是从开始的两个小时到整个晚餐准备任务。第二个截止日期是从我们开始腌制算起的30分钟，它只适用于任务的那一部分。</p>
<p>注意，我们等待切蔬菜，然后开始腌制。这是为了说明下面的观点：想象一下，不知怎么地，因为某种原因切蔬菜花了1小时40分钟。现在我们已经到了腌肉的步骤，离截止日期只有20分钟了，但是我们试图把截止日期设定在“30分钟后”。如果我们在这里设置了30分钟的截止日期，我们就会超过外部的最后期限。相反，任务会自动注意到<code>now + 30 minutes</code>的新截止日期实际上大于当前的截止日期，因此它被忽略；任务将在两个小时后适当地取消。</p>
<p>截止日期也可以以编程的方式进行交互。例如，<code>cook</code>函数确切地知道完成它需要多长时间。在<code>cook()</code>函数开始时检查是否取消只意味着还没有超过截止日期，但我们可以做得更好：我们可以检查是否还剩下三个小时。如果没有，我们可以立即抛出错误，告诉用户我们不会满足期限：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cook</span><span class="params">(<span class="number">_</span> dish: Dish, duration: Duration)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Meal</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> await <span class="type">Task</span>.currentDeadline().remaining &gt; duration <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">throw</span> await <span class="type">NotEnoughTimeToPrepareMealError</span>(<span class="string">"Not enough time to prepare meal!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正因为如此，那些拥有已知执行时间的函数可以在开始工作之前进行主动取消，因为我们知道这些工作最终会超过截止日期。</p>
<h3 id="通过async-let修饰的子任务"><a href="#通过async-let修饰的子任务" class="headerlink" title="通过async let修饰的子任务"></a>通过<code>async let</code>修饰的子任务</h3><p>异步调用本身不会引入并发执行。然而，<code>async</code>函数可以方便地使用<code>async let</code>让一个子任务中运行的工作并发运行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">let</span> result = <span class="keyword">try</span> fetchHTTPContent(of: url)</span><br></pre></td></tr></table></figure>
<p>任何对在<code>async let</code>中声明的变量的引用都是一个挂起点，相当于对异步函数的调用，所以它必须出现在await表达式中。<code>async let</code>的初始化被认为是由隐式<code>await</code>表达式括起来的。</p>
<p>如果<code>async let</code>的初始化可以抛出错误，那么对该<code>async let</code>中声明的变量子句的每个引用都被认为可以抛出错误，因此也必须包含在一个<code>try/try!/try?</code>之中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  async <span class="keyword">let</span> (yay, nay) = (<span class="string">"yay"</span>, <span class="keyword">throw</span> <span class="type">Nay</span>())</span><br><span class="line">  </span><br><span class="line">  await <span class="keyword">try</span> yay <span class="comment">// must be marked with `try`; throws Nay()</span></span><br><span class="line">  <span class="comment">// implicitly guarantees `nay` also be completed at this point</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，赋值语句右边是由<code>async let</code>修饰的，在初始化时也是在一起的（就像是异步回调一样），这意味着如果右边的任何值在初始化时抛出错误，所有左边要初始化的变量必须被视为它他们也抛出了同样的错误。</p>
<p>还有一种情况可能需要简短解释一下。在一个<code>async let</code>中的多个子句可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  async</span><br><span class="line"><span class="keyword">let</span> </span><br><span class="line">    ok = <span class="string">"ok"</span>,</span><br><span class="line">    (yay, nay) = (<span class="string">"yay"</span>, <span class="keyword">throw</span> <span class="type">Nay</span>())</span><br><span class="line">  </span><br><span class="line">  await ok</span><br><span class="line">  await <span class="keyword">try</span> yay</span><br><span class="line">  <span class="comment">// okay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们可以把每个子句看作是它自己的异步初始化变量，即<code>ok</code>单独初始化，<code>(yay, nay)</code>一起初始化，正如前面讨论的那样。</p>
<p>通过<code>async let</code>修饰的子句的至少一个变量在超出作用域之前，必须在所有执行路径（不会抛出错误）中<code>await</code>至少一次。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  async <span class="keyword">let</span> result = <span class="keyword">try</span> fetchHTTPContent(of: url)</span><br><span class="line">  <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="keyword">let</span> header = await <span class="keyword">try</span> result.header</span><br><span class="line">    <span class="comment">// okay, awaited `result`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error: did not await 'result' along this path. Fix this with, e.g.,</span></span><br><span class="line">    <span class="comment">//   _ = await try result</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>async let</code>的作用域通过抛出错误而退出，则隐式取消与<code>async let</code>对应的子任务。如果子任务已经完成，则丢弃其结果（或抛出错误）。</p>
<blockquote>
<p>原理阐述：在所有（非抛出）路径中，每个<code>async let</code>都需要<code>await</code>一个变量，这可以确保在正常执行过程中不会创建和隐式取消子任务。这样的代码可能是不必要的低效的，应该重新构造代码以避免创建不必要的子任务。</p>
</blockquote>
<h3 id="带有Nursery的子任务"><a href="#带有Nursery的子任务" class="headerlink" title="带有Nursery的子任务"></a>带有Nursery的子任务</h3><p>除了<code>async let</code>之外，这个建议还引入了显式的<code>Nursery</code>类型，它允许在这样的任务组中对任务进行细粒度的范围界定。</p>
<p>任务可以动态地被添加到任务组，这意味着可以为动态大小集合的每个元素添加任务到任务组，并将它们都绑定到任务组的生命周期。这与<code>async let</code>的声明相矛盾，后者只允许在编译时静态获取声明的任务数量。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Starts a new task group which provides a scope in which a dynamic number of</span></span><br><span class="line">  <span class="comment">/// tasks may be spawned.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Tasks added to the group by `group.add()` will automatically be awaited on</span></span><br><span class="line">  <span class="comment">/// when the scope exits. If the group exits by throwing, all added tasks will</span></span><br><span class="line">  <span class="comment">/// be cancelled and their results discarded.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// ### Implicit awaiting</span></span><br><span class="line">  <span class="comment">/// When results of tasks added to the group need to be collected, one can</span></span><br><span class="line">  <span class="comment">/// gather their results using the following pattern:</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">///     while let result = await group.next() &#123;</span></span><br><span class="line">  <span class="comment">///       // some accumulation logic (e.g. sum += result)</span></span><br><span class="line">  <span class="comment">///     &#125;</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// ### Cancellation</span></span><br><span class="line">  <span class="comment">/// If an error is thrown out of the task group, all of its remaining tasks</span></span><br><span class="line">  <span class="comment">/// will be cancelled and the `withGroup` call will rethrow that error.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Individual tasks throwing results in their corresponding `try group.next()`</span></span><br><span class="line">  <span class="comment">/// call throwing, giving a chance to handle individual errors or letting the</span></span><br><span class="line">  <span class="comment">/// error be rethrown by the group.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Postcondition:</span></span><br><span class="line">  <span class="comment">/// Once `withGroup` returns it is guaranteed that the `group` is *empty*.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This is achieved in the following way:</span></span><br><span class="line">  <span class="comment">/// - if the body returns normally:</span></span><br><span class="line">  <span class="comment">///   - the group will await any not yet complete tasks,</span></span><br><span class="line">  <span class="comment">///     - if any of those tasks throws, the remaining tasks will be cancelled,</span></span><br><span class="line">  <span class="comment">///   - once the `withGroup` returns the group is guaranteed to be empty.</span></span><br><span class="line">  <span class="comment">/// - if the body throws:</span></span><br><span class="line">  <span class="comment">///   - all tasks remaining in the group will be automatically cancelled.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">withGroup</span>&lt;TaskResult, BodyResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    resultType: TaskResult.<span class="keyword">Type</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    returning returnType: BodyResult.<span class="keyword">Type</span> = BodyResult.<span class="keyword">self</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    body: <span class="params">(<span class="keyword">inout</span> Task.Group&lt;TaskResult&gt;)</span></span></span> async <span class="keyword">throws</span> -&gt; <span class="type">BodyResult</span></span><br><span class="line">  ) async <span class="keyword">rethrows</span> -&gt; <span class="type">BodyResult</span> &#123; ... &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务组可以从任何异步上下文中启动，最终返回单个值（BodyResult）。任务可以动态地被添加进去，任务组在返回最终结果时断言所有任务都是空的，从而强制在返回之前等待所有任务的完成。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123; </span><br><span class="line">  <span class="comment">/* @unmoveable */</span> </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Nursery</span>&lt;<span class="title">TaskResult</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// No public initializers</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Swift will statically prevent this type from being copied or moved.</span></span><br><span class="line">    <span class="comment">// For now, that implies that it cannot be used with generics.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Add a child task.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        overridingPriority: Priority? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        operation: <span class="params">()</span></span></span> async -&gt; <span class="type">TaskResult</span></span><br><span class="line">    ) &#123; ... &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Add a child task and return a handle that can be used to manage it.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">addWithHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        overridingPriority: Priority? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        operation: <span class="params">()</span></span></span> async -&gt; <span class="type">TaskResult</span></span><br><span class="line">    ) -&gt; <span class="type">Handle</span>&lt;<span class="type">TaskResult</span>&gt; &#123; ... &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Wait for a child task to complete and return the result it returned,</span></span><br><span class="line">    <span class="comment">/// or else return.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> async -&gt; <span class="type">TaskResult</span>? &#123; ... &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Query whether the task group has any remaining tasks.</span></span><br><span class="line">    <span class="comment">/// Nurseries are always empty upon entry to the Task.withGroup body.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123; ... &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Cancel all the remaining tasks in the task group.</span></span><br><span class="line">    <span class="comment">/// Any results, including errors thrown, are discarded.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelAll</span><span class="params">()</span></span> &#123; ... &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务组保证它将在返回之前<code>await</code>所有被添加的任务的完成。</p>
<p>这种等待可以通过这样几种方式实现：</p>
<ul>
<li>任务组内部代码实现</li>
<li>在返回时默认完成</li>
</ul>
<p>在<code>chopVegetables()</code>示例中，我们不仅向任务组添加了切蔬菜任务，而且还获取了切蔬菜的结果。下面是对一般模式的简化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chopVegetables</span><span class="params">(rawVeggies: [Vegetable])</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">ChoppedVegetable</span>] &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withGroup(resultType: <span class="type">ChoppedVegetable</span>.<span class="keyword">self</span>) &#123; task group <span class="keyword">in</span>    </span><br><span class="line">    <span class="keyword">var</span> choppedVeggies: [<span class="type">ChoppedVegetable</span>] = []</span><br><span class="line">    choppedVeggies.reserveCapacity(veggies.<span class="built_in">count</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// add all chopping tasks and process them concurrently</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> rawVeggies &#123;</span><br><span class="line">      await <span class="keyword">try</span> task group.add &#123; <span class="comment">// await the successful adding of the task </span></span><br><span class="line">        await v.chopped() <span class="comment">// await the processing result of task</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> choppedVeggie = await <span class="keyword">try</span> task group.next() &#123; </span><br><span class="line">      choppedVeggies.append(choppedVeggie)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> choppedVeggies</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Nurseries：错误与取消机制"><a href="#Nurseries：错误与取消机制" class="headerlink" title="Nurseries：错误与取消机制"></a>Nurseries：错误与取消机制</h3><p>这里值得指出的是，将任务添加到任务组可能会失败，因为当我们要向任务组添加更多任务时，任务组可能已经被取消了。为了形象化这一点，让我们考虑下面的例子：</p>
<p>默认情况下，任务组中的任务处理抛出错误的方式就像《三个火枪手》那句经典语录一样，即：“我为人人，人人为我！”换句话说，如果单个任务抛出一个错误，该错误将转义到任务组中，那么所有其他任务将被取消，而任务组将重新抛出该错误。</p>
<p>为了形象化，让我们再考虑一下切蔬菜的问题。洋葱是一种很难切的蔬菜，如果你不小心，它们会让你流泪。如果我们试图切这些蔬菜，<code>onion</code>将向<code>task group</code>抛出一个错误，导致所有其他任务被自动取消：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chopOnionsAndCarrots</span><span class="params">(rawVeggies: [Vegetable])</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Vegetable</span>] &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withGroup &#123; task group <span class="keyword">in</span> <span class="comment">// (3) will re-throw the onion chopping error</span></span><br><span class="line">    <span class="comment">// kick off asynchronous vegetable chopping:</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> rawVeggies &#123;</span><br><span class="line">      await <span class="keyword">try</span> task group.add &#123; </span><br><span class="line">        await <span class="keyword">try</span> v.chopped() <span class="comment">// (1) throws</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// collect chopped up results:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> choppedVeggie = await <span class="keyword">try</span> task group.next() &#123; <span class="comment">// (2) will throw for the onion</span></span><br><span class="line">      choppedVeggies.append(choppedVeggie)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们把<code>chopOnionsAndCarrots()</code>函数分解成多个步骤来完全理解它的语义：</p>
<ol>
<li>添加切蔬菜的子任务进入任务组</li>
<li>异步处理不同的子任务</li>
<li>最终会处理到切洋葱任务然后抛出错误</li>
</ol>
<h3 id="任务组：父任务的取消机制"><a href="#任务组：父任务的取消机制" class="headerlink" title="任务组：父任务的取消机制"></a>任务组：父任务的取消机制</h3><p>到目前为止，我们还没有讨论取消任务组的问题。如果创建任务组的任务被取消，则可以取消任务组。取消任务组将取消其中的所有任务。试图在已取消的任务组中添加更多任务将抛出<code>CancellationError</code>。下面的例子说明了这些语义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WorkItem</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">    await <span class="keyword">try</span> <span class="type">Task</span>.checkCancellation() <span class="comment">// (4)</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = <span class="type">Task</span>.runDetached &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withGroup(resultType: <span class="type">Int</span>.<span class="keyword">self</span>) &#123; task group <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> processed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> workItems &#123; <span class="comment">// (3)</span></span><br><span class="line">      <span class="keyword">try</span> await task group.add &#123; await w.process() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> result = <span class="keyword">try</span> await task group.next() &#123; </span><br><span class="line">      processed += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> processed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle.cancel() <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> await handle.<span class="keyword">get</span>() <span class="comment">// will throw CancellationError // (2)</span></span><br></pre></td></tr></table></figure>
<p>有多种方法可以取消任务，但是在本例中，让我们考虑显式取消一个分离的任务。此任务是任务组的父任务，因此，当父任务的<code>handle.cancel()</code>被调用时，取消将被传递给它。</p>
<p>任务组在创建新子任务或等待子任务完成时会自动检查父任务的取消。如果系统承受较大负载，添加新任务也可能挂起，这是对正在添加到系统的新任务“队列”的一种形式上的反压。考虑到这些因素，程序员可以写出直观、自然的代码，在默认情况下仍然可以做正确的事情。</p>
<h3 id="任务组：隐式地等待任务"><a href="#任务组：隐式地等待任务" class="headerlink" title="任务组：隐式地等待任务"></a>任务组：隐式地等待任务</h3><p>有时不需要收集异步函数的结果（例如，因为它们可能返回<code>Void</code>)，在这种情况下，我们可以依赖任务组隐式地等待所有已启动的任务返回。</p>
<p>在下面的例子中，我们需要确认我们收到的每一个订单，但是该确认没有返回任何有用的值给我们（它要么是<code>Void</code>，要么我们只是选择忽略返回值）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">confirmOrders</span><span class="params">(orders: [Order])</span></span> async <span class="keyword">throws</span> &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withGroup &#123; task group <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">for</span> order <span class="keyword">in</span> orders &#123;</span><br><span class="line">      await <span class="keyword">try</span> task group.add &#123; await order.confirm() &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>confirmOrders()</code>函数将只在所有确认完成时返回，因为任务组将等待任何未完成的任务。</p>
<h3 id="分离任务-1"><a href="#分离任务-1" class="headerlink" title="分离任务"></a>分离任务</h3><p>分离任务是本提供中提供的两个“救生圈”api之一（另一个是下一节讨论的<code>UnsafeContinuation</code>），用于结构化并发规则对于特定异步操作过于严格的情况。</p>
<p>看看前面提到的在分离任务中做晚餐的例子，我们填写一下缺失的类型和细节：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dinnerHandle: <span class="type">Task</span>.<span class="type">Handle</span>&lt;<span class="type">Dinner</span>&gt; = <span class="type">Task</span>.runDetached &#123;</span><br><span class="line">  await makeDinner()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optionally, someone, somewhere may cancel the task:</span></span><br><span class="line"><span class="comment">// dinnerHandle.cancel()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dinner = await <span class="keyword">try</span> dinnerHandle.<span class="keyword">get</span>()</span><br></pre></td></tr></table></figure>
<p><code>runDetached</code>返回了一个<code>Task.Handle</code>这提供了任务逃逸的引用，允许等待或取消任务。</p>
<p><code>get()</code>函数总是<code>throwing</code>（即使任务的代码没有抛出）<code>CancellationError</code>，因此等待<code>handle</code>的<code>get()</code>总是<code>throwing</code>，即使被封装的操作本身没有抛出错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span>&lt;<span class="title">Success</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Success</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="底层代码和通过UnsafeContinuation集成遗留api"><a href="#底层代码和通过UnsafeContinuation集成遗留api" class="headerlink" title="底层代码和通过UnsafeContinuation集成遗留api"></a>底层代码和通过<code>UnsafeContinuation</code>集成遗留api</h3><p>异步代码的底层执行有时需要避开异步函数和任务组的高级抽象。此外，使API能够与现有的非异步代码交互，同时仍然能够向此类API的用户提供一个令人愉快的使用基于异步函数的接口，这一点非常重要。</p>
<p>对于这种情况，本提议提出了<code>Unsafe(Throwing)Continuation</code>的概念：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeContinuation</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    operation: <span class="params">(UnsafeContinuation&lt;T&gt;)</span></span></span> -&gt; ()</span><br><span class="line">  ) async -&gt; <span class="type">T</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnsafeContinuation</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(...) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">resume</span><span class="params">(returning: T)</span></span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeThrowingContinuation</span>&lt;T, E: Error&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    operation: <span class="params">(UnsafeThrowingContinuation&lt;T, E&gt;)</span></span></span> -&gt; ()</span><br><span class="line">  ) async <span class="keyword">throws</span> -&gt; <span class="type">T</span> &#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">UnsafeThrowingContinuation</span>&lt;<span class="title">T</span>, <span class="title">E</span>: <span class="title">Error</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>(...) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">resume</span><span class="params">(returning: T)</span></span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">resume</span><span class="params">(throwing: E)</span></span> &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UnsafeContinuation</code>允许封装现有的基于回调的复杂api，并将它们呈现给调用者，就像它是一个普通的异步函数一样。</p>
<p>处理<code>UnsafeContinuation</code>的规则：</p>
<ul>
<li><code>resume</code>函数只能在操作可能采取的每个执行路径(包括任何错误处理路径)上精确调用一次，</li>
<li><code>resume</code>函数必须恰好在<code>operation</code>函数执行结束时被调用，否则将无法为<code>operation</code>函数中的捕获定义有用的语义，即它将与<code>continuation</code>并行；不幸的是，这不可避免地给使用延续带来了一些开销。</li>
</ul>
<p>使用这个API，我们可以包装这样的函数（为了展示<code>continuation</code>API的灵活性，这里故意写得复杂了一些)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyVegetables</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  shoppingList: [String],</span></span></span><br><span class="line"><span class="function"><span class="params">  // a)</span></span> <span class="keyword">if</span> all veggies were <span class="keyword">in</span> store, this <span class="keyword">is</span> invoked *exactly-once*</span><br><span class="line">  onGotAllVegetables: ([<span class="type">Vegetable</span>]) -&gt; (),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// b) if not all veggies were in store, invoked one by one *one or more times*</span></span><br><span class="line">  onGotVegetable: (<span class="type">Vegetable</span>) -&gt; (),</span><br><span class="line">  <span class="comment">// b) if at least one onGotVegetable was called *exactly-once*</span></span><br><span class="line">  <span class="comment">//    this is invoked once no more veggies will be emitted</span></span><br><span class="line">  onNoMoreVegetables: () -&gt; (),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// c) if no veggies _at all_ were available, this is invoked *exactly once*</span></span><br><span class="line">  onNoVegetablesInStore: (<span class="type">Error</span>) -&gt; ()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// returns 1 or more vegetables or throws an error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buyVegetables</span><span class="params">(shoppingList: [String])</span></span> async <span class="keyword">throws</span> -&gt; [<span class="type">Vegetable</span>] &#123;</span><br><span class="line">  await <span class="keyword">try</span> <span class="type">Task</span>.withUnsafeThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">var</span> veggies: [<span class="type">Vegetable</span>] = []</span><br><span class="line"></span><br><span class="line">    buyVegetables(</span><br><span class="line">      shoppingList: shoppingList,</span><br><span class="line">      onGotAllVegetables: &#123; veggies <span class="keyword">in</span> continuation.resume(returning: veggies) &#125;,</span><br><span class="line">      onGotVegetable: &#123; v <span class="keyword">in</span> veggies.append(v) &#125;,</span><br><span class="line">      onNoMoreVegetables: &#123; continuation.resume(returning: veggies) &#125;,</span><br><span class="line">      onNoVegetablesInStore: &#123; error <span class="keyword">in</span> continuation.resume(throwing: error) &#125;,</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> veggies = await <span class="keyword">try</span> buyVegetables(shoppingList: [<span class="string">"onion"</span>, <span class="string">"bell pepper"</span>])</span><br></pre></td></tr></table></figure>
<p>多亏将正确的<code>continuation resume</code>调用编写到<code>buyVegetables</code>函数的复杂回调中，我们才能够提供这个函数的更好的重载，允许我们的用户依赖<code>async</code>/<code>await</code>来与这个函数交互。</p>
<blockquote>
<p>挑战性：理论上，提供编译器诊断来帮助开发人员避免多次<code>resume</code>（或者根本不<code>resume</code>）的错误是可能的。</p>
<p>然而，由于这个API的主要用例通常是与复杂的回调风格的API集成（如上面所示的<code>buyVegetables</code>），编译器通常不可能获得关于每个回调语义的足够信息，从而产生关于正确使用这个不安全API的诊断指导。</p>
<p>开发人员必须谨慎地调用<code>resume</code>，以保证正确恢复语义，如果不考虑应该调用<code>resume</code>的情况，将导致任务永远挂起，这证明了这个API的不安全表示是正确的。</p>
</blockquote>
<h3 id="关于任务api的一些杂项"><a href="#关于任务api的一些杂项" class="headerlink" title="关于任务api的一些杂项"></a>关于任务api的一些杂项</h3><h4 id="自愿暂停"><a href="#自愿暂停" class="headerlink" title="自愿暂停"></a>自愿暂停</h4><p>对于某些任务的长时间运行操作，比如在一个小循环中执行大量任务，有时候可能会有利于让任务检查他们是否应该被暂停，并为其他任务提供一个继续进行的机会（例如，如果所有任务都在一个有限并行的共享池中执行）。对于这个例子，<code>Task</code>引入了一个<code>yield()</code>操作，这是一种显式挂起并让其他任务有机会运行一段时间的方法。</p>
<p>这并不是解决任务饥饿的完美方法——如果任务是系统中最高优先级的任务，它可能会立即返回执行任务——但是它可能是针对长时间运行任务的有用的特定模式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">yield</span><span class="params">()</span></span> async &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以将任务挂起，直到任意的截止日期为止。这类似于同步函数中的“休眠线程”，但是不会导致任何阻塞线程的代价。<code>Task.sleep(until:)</code>函数是异步的，只在给定的时间点之前挂起任务。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Suspend until a given point in time.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// ### Cancellation</span></span><br><span class="line">  <span class="comment">/// Does not check for cancellation and suspends the current context until the</span></span><br><span class="line">  <span class="comment">/// given deadline.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// - Parameter until: point in time until which to suspend.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span><span class="params">(until: Deadline)</span></span> async &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"\(#function) not implemented yet."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该功能不会自动检查取消，因此如果想检查是否超过了期限，则需要在休眠任务之前手动检查。</p>
<h2 id="源码兼容性"><a href="#源码兼容性" class="headerlink" title="源码兼容性"></a>源码兼容性</h2><p>这个提议只是一些新内容的添加。在<code>async let</code>中额外使用关键字<code>async</code>接受新代码是格式良好的，不会破坏或改变现有代码的含义。</p>
<h2 id="对ABI稳定性的影响"><a href="#对ABI稳定性的影响" class="headerlink" title="对ABI稳定性的影响"></a>对ABI稳定性的影响</h2><p>无</p>
<h2 id="对API弹性的影响"><a href="#对API弹性的影响" class="headerlink" title="对API弹性的影响"></a>对API弹性的影响</h2><p>无</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/09/asyncawait/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/09/asyncawait/" itemprop="url">Async/await</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-09T00:15:17+08:00">
                2020-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文链接：<a href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md" target="_blank" rel="noopener">Async/await proposal</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现代Swift开发会涉及到大量的异步编程，一般来说我们通过回调来完成，但是回调的api非常难以使用。当代码涉及了非常多的异步操作，还要进行错误处理，并且回调之间互相依赖时，这会带来非常大的麻烦。本提议描述了对语言的拓展，让这一切变得更自然更不易出错。</p>
<p>我们打算为Swift引入协程的模型。函数可以是异步的，这让程序员们能够使用正常的控制流来编写包含异步操作的复杂逻辑。编译器负责将异步函数转换为一组适当的闭包和状态机。</p>
<p>这个提议定义了异步函数的语义，但是不提供并发行，并发性相关建议会在另外一个提议中详细阐述。并发性的提议会将异步函数与并发执行的任务相关联，并提供创建、查询和取消任务的api。</p>
<p>本提议从Chris Lattner和Joe Groff之前写的一个提议中得到了很多启发。提议本身源于<a href="https://gist.github.com/oleganza/7342ed829bddd86f740a" target="_blank" rel="noopener">Oleg Andreev的提议</a>。显然，很多内容都经过了重写，细节也发生了改变，但是核心思想仍然是一致的。</p>
<h2 id="动机：回调不是最优解"><a href="#动机：回调不是最优解" class="headerlink" title="动机：回调不是最优解"></a>动机：回调不是最优解</h2><p>在异步编程中使用显式回调（也称为完成回调）有许多问题，我们将在下面探讨这些问题。提议通过在语言中引入异步函数来解决这些问题。异步函数允许将异步代码写成单行的形式。它们还能实现直接推断代码的执行模式，从而让回调更有效地运行。</p>
<h3 id="问题一：回调地狱"><a href="#问题一：回调地狱" class="headerlink" title="问题一：回调地狱"></a>问题一：回调地狱</h3><p>一系列简单的异步操作通常需要深度嵌套的闭包。下面是一个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData1</span><span class="params">(completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource <span class="keyword">in</span></span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource <span class="keyword">in</span></span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp <span class="keyword">in</span></span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData1 &#123; image <span class="keyword">in</span></span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种回调地狱使得阅读和跟踪代码运行的位置变得非常困难。此外，使用一堆闭包会导致许多二阶效应，我们将在下文中讨论。</p>
<h3 id="问题二：错误处理"><a href="#问题二：错误处理" class="headerlink" title="问题二：错误处理"></a>问题二：错误处理</h3><p>回调使错误处理变得非常困难和冗长。Swift 2为同步代码引入了一个错误处理模型，但是基于回调的接口并没有从中得到任何好处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            decodeImage(dataResource, imageResource) &#123; imageTmp, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> imageTmp = imageTmp <span class="keyword">else</span> &#123;</span><br><span class="line">                    completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">guard</span> <span class="keyword">let</span> imageResult = imageResult <span class="keyword">else</span> &#123;</span><br><span class="line">                        completionBlock(<span class="literal">nil</span>, error)</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    completionBlock(imageResult)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; image, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> image = image <span class="keyword">else</span> &#123;</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    display(image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Result</code>的加入让Swift的api在错误处理这一块得到了提升。异步api也是<code>Result</code>的引入的一个重要动机：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">(completionBlock: <span class="params">(Result&lt;Image&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResourceResult <span class="keyword">in</span></span><br><span class="line">        dataResourceResult.<span class="built_in">map</span> &#123; dataResource <span class="keyword">in</span></span><br><span class="line">            loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResourceResult <span class="keyword">in</span></span><br><span class="line">                imageResultResult.<span class="built_in">map</span> &#123; imageResource <span class="keyword">in</span></span><br><span class="line">                    decodeImage(dataResource, imageResource) &#123; imageTmpResult <span class="keyword">in</span></span><br><span class="line">                        imageTmpResult.<span class="built_in">map</span> &#123; imageTmp <span class="keyword">in</span> </span><br><span class="line">                            dewarpAndCleanupImage(imageTmp) &#123; imageResult <span class="keyword">in</span></span><br><span class="line">                                completionBlock(imageResult)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processImageData2 &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> image):</span><br><span class="line">        display(image)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        error(<span class="string">"No image today"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用<code>Result</code>时，我们更容易正确地处理错误，从而缩短代码。但是，回调地狱问题仍然存在。</p>
<h3 id="问题三：条件执行很困难并且容易出错"><a href="#问题三：条件执行很困难并且容易出错" class="headerlink" title="问题三：条件执行很困难并且容易出错"></a>问题三：条件执行很困难并且容易出错</h3><p>通过执行异步函数是一件非常痛苦的事情。举个例子，假设我们需要在获得图像后对其进行<code>swizzle</code>。我们可能不得不在<code>swizzle</code>之前执行一些异步代码。也许构造这个函数的最好的函数是把swizzle的代码组织成一个逃逸闭包，并在异步函数的完成回调中被捕获，像这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData3</span><span class="params">(recipient: Person, completionBlock: <span class="params">(result: Image)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> swizzle: (contents: image) -&gt; <span class="type">Void</span> = &#123;</span><br><span class="line">      <span class="comment">// ... continuation closure that calls completionBlock eventually</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        swizzle(recipient.profilePicture)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decodeImage &#123; image <span class="keyword">in</span></span><br><span class="line">            swizzle(image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种模式颠倒了一个函数自上而下的组织方式：在函数的后半部分执行的代码出现在了前半部分。除了重新构造整个函数之外，我们现在还必须仔细考虑闭包的捕获，因为这个闭包是在完成回调中使用的。随着条件执行的异步函数数量的增加，问题会进一步恶化，从而产生实质上的回调地狱。</p>
<h3 id="问题四：实在太容易出错了"><a href="#问题四：实在太容易出错了" class="headerlink" title="问题四：实在太容易出错了"></a>问题四：实在太容易出错了</h3><p>只需简单地返回，不调用正确的完成回调，就可以很容易地提前退出异步操作。当你搞忘了的时候，这个问题是很难调试的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData4</span><span class="params">(completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    loadWebResource(<span class="string">"dataprofile.txt"</span>) &#123; dataResource, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> dataResource = dataResource <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">        &#125;</span><br><span class="line">        loadWebResource(<span class="string">"imagedata.dat"</span>) &#123; imageResource, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> imageResource = imageResource <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="comment">// &lt;- forgot to call the block</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你记得调用回调时，你仍然可能会忘记在调用回调之后返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData5</span><span class="params">(recipient:Person, completionBlock: <span class="params">(result: Image?, error: Error?)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> recipient.hasProfilePicture &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> image = recipient.profilePicture &#123;</span><br><span class="line">            completionBlock(image) <span class="comment">// &lt;- forgot to return after calling the block</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幸运的是，<code>guard</code>语法在某种程度上让你避免了忘记返回的情况，但它并不能给你永远的保护。</p>
<h3 id="问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"><a href="#问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了" class="headerlink" title="问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了"></a>问题五：因为完成回调的尴尬处境，很多api被设计成同步的形式了</h3><p>虽然很难量化，但笔者认为，使用回调的尴尬导致许多api被定义为同步行为，甚至在它们可能阻塞的时候。这可能会导致UI应用程序的性能和响应性问题，例如loading光标。它还会导致一些api无法在异步对规模至关重要的情况下使用，比如在服务器上。</p>
<h2 id="解决方案：async-await"><a href="#解决方案：async-await" class="headerlink" title="解决方案：async/await"></a>解决方案：async/await</h2><p>异步函数——通常称为<code>async/await</code>——允许异步代码像单行的同步代码一样编写。通过允许程序员充分使用同步代码可用的相同语言结构，它可以立即解决上面描述的许多问题。使用<code>async/await</code>也自然地保留了代码的语义结构，提供了至少三个对语言的改进所必需的信息：</p>
<ol>
<li>更好的异步代码性能</li>
<li>更好的工具，在调试、剖析和探索代码时提供更一致的体验</li>
<li>为将来的并发特性（如任务的优先级和取消）奠定基础。</li>
</ol>
<p>我们使用前面的例子演示一下<code>async/await</code>如何大大简化异步代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadWebResource</span><span class="params">(<span class="number">_</span> path: String)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Resource</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeImage</span><span class="params">(<span class="number">_</span> r1: Resource, <span class="number">_</span> r2: Resource)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dewarpAndCleanupImage</span><span class="params">(<span class="number">_</span> i : Image)</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processImageData2</span><span class="params">()</span></span> async <span class="keyword">throws</span> -&gt; <span class="type">Image</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> dataResource  = await <span class="keyword">try</span> loadWebResource(<span class="string">"dataprofile.txt"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageResource = await <span class="keyword">try</span> loadWebResource(<span class="string">"imagedata.dat"</span>)</span><br><span class="line">  <span class="keyword">let</span> imageTmp      = await <span class="keyword">try</span> decodeImage(dataResource, imageResource)</span><br><span class="line">  <span class="keyword">let</span> imageResult   = await <span class="keyword">try</span> dewarpAndCleanupImage(imageTmp)</span><br><span class="line">  <span class="keyword">return</span> imageResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>许多关于<code>async/await</code>的实现描述都是一个通用的机制：将函数切割为多个部分的编译器传递。这在抽象的底层层次上理解机器是如何运行的是很重要的，但在更高层次上，我们希望您忽略它。相反，可以将异步函数看作具有放弃线程的特殊能力的普通函数。异步函数通常不会直接使用这种能力；相反，它们只是进行方法调用，有时这些调用将要求它们放弃线程并等待某些事情发生。当该操作完成时，函数将继续执行。</p>
<p>这与同步函数有很强的相似性。同步函数的调用会在调用完成前等待，在调用完成后返回。一旦调用完成，控制流会回到调用时的位置并从它停止的地方继续。异步函数也是如此：它可以像往常一样调用；当进行调用时，它通常会立即等待调用的完成。一旦调用完成，控制权就返回到函数，恢复到原来的位置。唯一的区别是同步函数可以充分利用部分它们的线程及其堆栈，而异步函数可以完全放弃堆栈而使用它们自己单独的存储区域。异步函数的这种额外功能有一些实现成本，但我们可以通过围绕它进行整体设计来降低成本。</p>
<p>因为异步函数必须能够放弃自己的线程，而同步函数不知道如何放弃一个线程，所以同步函数通常不能调用异步函数：异步函数只能放弃它占领的线程的一部分。如果进行一下这样的尝试，同步函数中调用一个异步函数，同步函数需要等待异步函数的返回。一般来说，实现这一功能的唯一方式是阻塞整个线程，直到异步函数恢复并完成，那这将完全违背异步函数的目的，并会造成恶劣的系统影响。</p>
<p>相反，异步函数既可以调用同步函数也可以调用异步函数。当然，在调用同步函数时，它不能放弃线程。实际上，异步函数不会直接放弃线程；它们只有在到达所谓的挂起点时才会放弃线程，挂起点就是<code>await</code>。挂起点可以直接发生在一个函数中，也可以发生在该函数调用的另一个异步函数中，但在任何一种情况下，该函数及其所有异步调用者都会同时放弃线程。(在实践中，异步函数在编译时不依赖于异步调用期间的线程，因此只有最内层的函数需要做一些额外的工作。)</p>
<p>当控制流返回到一个异步函数时，它会准确地恢复到原来的位置。这并不一定意味着它将在与之前完全相同的线程上运行，因为语言层不能保证在挂起之后会这样做。在这种设计中，线程主要是一种实现机制，而不是预期的并发接口的一部分。然而，许多异步函数并不仅仅是异步的：它们还与特定的<code>actor</code>相关联，并且它们总是作为<code>actor</code>的一部分运行。Swift保证这些函数实际上将返回到其<code>actor</code>以完成执行。因此，直接使用线程进行状态隔离的库——例如，通过创建自己的线程并在线程上顺序调度任务——通常应该在Swift中将这些线程转化为<code>actor</code>，以在Swift中保证正常运行。</p>
<h3 id="挂起点"><a href="#挂起点" class="headerlink" title="挂起点"></a>挂起点</h3><p>挂起点是执行异步函数时放弃线程的点。挂起点总是与函数中一些确定性的、语法上明确的事件相关联；从函数的角度来看，它们不会是被隐藏的或异步的。详细的语言设计将把几个不同的操作描述为挂起点，但最重要的一个操作是对与不同上下文的异步函数的调用。</p>
<p>重要的是，挂起点只与显式操作相关联。事实上，这个提议要求将可能暂停的调用封装在一个<code>await</code>表达式中，这是非常重要的。这沿袭了Swift使用<code>try</code>表达式来处理可能引发错误的函数调用的先例。标记挂起点特别重要，因为挂起中断了原子性。例如，如果一个异步函数在一个受串行队列保护的上下文中运行，达到一个挂起点意味着其他代码可以交错在同一串行队列上。原子性的重要性可以体现在一个经典但有点老旧的例子：如果存款被存入一个帐户，但操作在处理匹配的取款之前暂停，那么它将创建一个时间窗口，在该窗口中可以重复使用这些资金。对许多Swift程序员来说，一个更贴切的例子是UI线程：挂起点是UI可以显示给用户的点，因此程序构建部分UI然后挂起的风险是呈现一个卡住了的、部分构造的UI。(注意，代码中也使用显式回调显式地调用挂起点：挂起发生在外部函数返回点和回调开始运行点之间。)我们要求所有的挂起点都被标记，这使得程序员可以安全地假定没有挂起点的地方将按照原子方式运行，并且更容易识别出有问题的非原子模式。</p>
<p>由于挂起点只能出现在异步函数中被显式标记的点上，因此长时间的计算仍然会阻塞线程。当调用一个只做大量工作的同步函数时，或者遇到直接在异步函数中编写的特别密集的计算循环时，可能会发生这种情况。在任何一种情况下，线程都不能在这些计算运行时交错代码，这通常是正确的选择，但也可能成为延展性问题。需要进行密集计算的异步程序通常应该在单独的上下文中运行。当这不可行的时候，将会有一些工具来人为地挂起并允许其他操作进行交叉。</p>
<p>异步函数应该避免调用那些实际上会阻塞线程的函数，特别是当它们阻塞线程的目的是等待哪些不能保证当前正在运行的工作完成的时候。例如，获取互斥锁的行为只能被阻塞，直到当前运行的线程放弃该互斥锁；这有时是可以接受的，但必须谨慎使用，以避免引入死锁或人为的延展性问题。相反，等待一个条件变量可能会阻塞，直到某个工作被调度，并通知该变量；这种模式与推荐的方式是背道而驰的。需要做一些工作来让程序避免这些缺陷。</p>
<p>当异步函数在另一个上下文中等待操作时，此设计目前没有提供阻止当前上下文并切换的函数。这种省略是有意为之的：为了防止出现死锁。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>对<code>async</code>函数的调用看上去和实际运行上都很像对同步函数的调用。调用一个<code>async</code>函数的语义是：</p>
<ul>
<li>参数是使用普通规则计算的，包括对任何inout参数的初始访问。</li>
<li>被调用者的执行者是确定的。该提议没有说明确定执行者的规则；参见关于<code>actor</code>的补充建议。</li>
<li>如果被调用者的执行者与调用者的执行者不同，则会发生挂起，在被调用者中恢复执行的部分任务会安排到被调用者的执行程序上。</li>
<li>被调用者在其执行者上使用给定的参数执行。</li>
<li>在返回期间，如果被调用者的执行者与调用者的执行者不同，则会发生挂起，并且在调用者中恢复执行的部分任务会安排到调用者的执行程序中。</li>
<li>最后，调用者在它的执行者上继续执行。如果被调用方正常返回，则调用表达式的结果为函数返回的值；否则，表达式将抛出被调用方抛出的错误。</li>
</ul>
<p>从调用方的角度来看，异步调用的行为类似于同步调用，除了它们可能在不同的执行者上执行，需要任务被暂时挂起。还要注意的是，由于调用上的挂起，inout访问的持续时间可能要长得多，因此inout对共享的可变状态的引用没有充分隔离，更有可能产生动态排他性冲突。</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>函数类型可以显式标记为<code>async</code>，表示函数是异步的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collect</span><span class="params">(function: <span class="params">()</span></span></span> async -&gt; <span class="type">Int</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>函数或初始化声明也可以显式声明为<code>async</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">init</span>(hiringFrom: <span class="type">College</span>) async <span class="keyword">throws</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">raiseHand</span><span class="params">()</span></span> async -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对声明为<code>async</code>的函数的引用以及初始化方法均是<code>async</code>函数类型 。如果引用是对实例方法的柯里化的静态引用，则内层的函数类型是异步的，这与此类引用的规则是一致的。</p>
<p>一些特殊的函数，比如<code>deinit</code>以及存储访问器不能标为<code>async</code>。</p>
<blockquote>
<p>原理阐述：只有getter的属性可能是<code>async</code>的。但是，同样具有异步setter的属性意味着能够将属性作为inout传递并深入到该属性本身，这取决于setter是否有效地是一个同步操作。禁止异步属性比只允许get的异步属性更简单。</p>
</blockquote>
<p>如果一个函数既是<code>async</code>又是<code>throws</code>，那么在声明时，<code>async</code>必须在<code>throws</code>之前。同样的规则也被应用在<code>async</code>和<code>rethrows</code>上。</p>
<blockquote>
<p>原理阐述：这种顺序限制没有很特别的理由，但它没有坏处，而且它消除了对风格的潜在争论。</p>
</blockquote>
<h3 id="异步函数类型"><a href="#异步函数类型" class="headerlink" title="异步函数类型"></a>异步函数类型</h3><p>异步函数类型不同于同步函数类型。不存在从同步函数类型到相应异步函数类型的隐式转换。但是，将非抛出异步函数类型的值隐式转换为相应的抛出异步函数类型是允许的。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctionTypes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> syncNonThrowing: () -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> syncThrowing: () <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> asyncNonThrowing: () async -&gt; <span class="type">Void</span></span><br><span class="line">  <span class="keyword">var</span> asyncThrowing: () async <span class="keyword">throws</span> -&gt; <span class="type">Void</span></span><br><span class="line">  </span><br><span class="line">  mutable <span class="function"><span class="keyword">func</span> <span class="title">demonstrateConversions</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Okay to convert to throwing form</span></span><br><span class="line">    syncThrowing = syncNonThrowing</span><br><span class="line">    asyncThrowing = asyncNonThrowing</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Error to convert between asynchronous and synchronous</span></span><br><span class="line">    asyncNonThrowing = syncNonThrowing <span class="comment">// error</span></span><br><span class="line">    syncNonThrowing = asyncNonThrowing <span class="comment">// error</span></span><br><span class="line">    asyncThrowing = syncThrowing       <span class="comment">// error</span></span><br><span class="line">    syncThrowing = asyncThrowing       <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以手动创建一个调用同步函数的<code>async</code>闭包，因此缺少隐式转换不会有表达能力上的影响。有关定义<code>async</code>闭包的语法，请参阅“闭包”一节。</p>
<blockquote>
<p>原理阐述：我们不建议使用从同步函数到异步函数的隐式转换，因为这会使类型检查复杂化，特别是在存在同一函数的同步和异步重载的情况。有关更多信息，请参阅“重载和重载解析”一节。</p>
</blockquote>
<h3 id="Await表达式"><a href="#Await表达式" class="headerlink" title="Await表达式"></a>Await表达式</h3><p>对<code>async</code>函数类型的值的调用（包括对<code>async</code>函数的直接调用）带来了一个挂起点。任何挂起点都必须发生在一个异步的上下文中（例如，一个<code>async</code>函数）。而且，它必须出现在<code>await</code>表达式的操作中。</p>
<p>看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func redirectURL(for url: URL) async -&gt; URL &#123; ... &#125;</span></span><br><span class="line"><span class="comment">// func dataTask(with: URL) async throws -&gt; URLSessionDataTask &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newURL = await server.redirectURL(<span class="keyword">for</span>: url)</span><br><span class="line"><span class="keyword">let</span> (data, response) = await <span class="keyword">try</span> session.dataTask(with: newURL)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，一个任务的挂起可能发生在<code>redirectURL(for:)</code>和<code>dataTask(with:)</code>中，因为它们都是异步函数。因此，两个调用表达式都必须包含在<code>await</code>表达式中，因为它们都包含了挂起点。尽管在<code>await</code>的操作中允许有多个挂起点，但<code>await</code>表达式的操作必须至少包含一个挂起点。例如，我们可以使用一个<code>await</code>来覆盖两个挂起点来重写上面的例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (data, response) = await <span class="keyword">try</span> session.dataTask(with: server.redirectURL(<span class="keyword">for</span>: url))</span><br></pre></td></tr></table></figure></p>
<p><code>await</code>没有其他的语义；像<code>try</code>一样，它只是标记正在进行异步调用。<code>await</code>表达式的类型是它的操作者的类型，返回结果是其操作者的结果。</p>
<blockquote>
<p>原理阐述：重要的是，异步调用必须在函数内被清晰地识别，因为它们引入了挂起点，这会破坏操作的原子性。挂起点可能是调用所固有的（因为异步调用必须在不同的执行者上执行），或者仅仅是被调用者实现的一部分，但是在任何一种情况下，它在语义上都是重要的，程序员需要有正确的认识。<code>await</code>表达式也是异步代码的指示符，它与闭包中的推断相关联；更多信息请参见“闭包”一节。</p>
</blockquote>
<p>挂起点不能出现在非<code>async</code>函数类型的自动闭包中。</p>
<p>挂起点不能出现在<code>defer</code>的block中。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个闭包可以具有<code>async</code>的函数类型。这样的闭包可以明确地标记为<code>async</code>，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; () async -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> await getInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果匿名闭包包含一个<code>await</code>表达式，则推断它具有<code>async</code>函数类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> closure = &#123; await getInt() &#125; <span class="comment">// implicitly async</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure2 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>     <span class="comment">// implicitly async</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> await getInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对闭包的<code>async</code>推断不会延伸到它的封闭性、嵌套函数或闭包，因为这些上下文不论异步或同步都是可分离的。例如，只有<code>closure6</code>在这种情况下被推断为<code>async</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func getInt() async -&gt; Int &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure5 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>       <span class="comment">// not 'async'</span></span><br><span class="line">  <span class="keyword">let</span> closure6 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span>     <span class="comment">// implicitly async</span></span><br><span class="line">    <span class="keyword">if</span> randomBool() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"there"</span>)</span><br><span class="line">      <span class="keyword">return</span> await getInt()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> closure7 = &#123; () -&gt; <span class="type">Int</span> <span class="keyword">in</span> <span class="number">7</span> &#125;  <span class="comment">// not 'async'</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"here"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载和重载解析"><a href="#重载和重载解析" class="headerlink" title="重载和重载解析"></a>重载和重载解析</h3><p>现有的包含一个操作同步和异步入口的Swift程序，可能会为每个操作使用两种命名相似的方法来设计：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(completionHandler: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在调用方看来上，通过是否传入回调可以清楚地了解正在调用哪个方法。然而，随着第二种方法的api直接映射到一个<code>async</code>函数，这两种方法现在非常相似：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> async -&gt; <span class="type">String</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">doSomething() <span class="comment">// synchronous or asynchronous?</span></span><br></pre></td></tr></table></figure>
<p>如果我们用<code>throws</code>替换<code>async</code>，声明上面的两个方法会产生一个“invalid redeclaration”的编译错误。但是，我们建议允许<code>async</code>函数重载非<code>async</code>函数，因此上面的代码是没问题的。这允许现有的Swift程序发展现有同步函数的<code>async</code>版本，而不会产生虚假的重命名。</p>
<p>重载<code>async</code>和非<code>async</code>函数的能力与重载解析规则相对应，根据调用的上下文选择适当的函数。对于一个调用，重载解析倾向于在同步上下文中使用非<code>async</code>函数，因为这样的上下文中不能包含对异步函数的调用。此外，重载解析倾向于在异步上下文中使用<code>async</code>函数，因为当有替代方法时，这样的上下文应该避免同步、阻塞api。当重载解析选择一个<code>async</code>函数时，该调用必须发生在一个await表达式中。</p>
<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>除非函数本身是<code>async</code>，否则函数不能使用<code>async</code>函数类型的自动闭包参数。例如，下面的声明格式是不正确的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: async autoclosure in a function that is not itself 'async'</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeArgumentLater</span>&lt;T&gt;<span class="params">(<span class="number">_</span> fn: @escaping @autoclosure <span class="params">()</span></span></span> async -&gt; <span class="type">T</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这一限制的存在有几个原因。考虑下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func getIntSlowly() async -&gt; Int &#123; ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  computeArgumentLater(await getIntSlowly())</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，<code>await</code>表达式告诉程序员调用<code>computeArgumentLater(_:)</code>会有一个挂起点，实际上并不是这样：挂起点位于被<code>computeArgumentLater(_:)</code>使用和传递的自动闭包内部。这导致了一些问题。首先，<code>await</code>出现在调用上这一事实意味着我们将推断闭包具有<code>async</code>函数类型，然而这也是不正确的：闭包中的所有代码都是同步的。其次，因为一个<code>await</code>的操作只需要包含一个暂停点在它的某个位置，一个等效的重写的调用应该是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await computeArgumentLater(getIntSlowly())</span><br></pre></td></tr></table></figure>
<p>但是，因为参数是一个自动闭包，所以这种重写没有保留它语义。因此，对<code>async</code>自动闭包参数的限制确保<code>async</code>自动闭包参数只能在异步上下文中使用，从而避免了这些问题。</p>
<h2 id="源码兼容性"><a href="#源码兼容性" class="headerlink" title="源码兼容性"></a>源码兼容性</h2><p>这个提议基本上只是一些新的添加：现有代码不会使用任何新特性（例如，不创建<code>async</code>函数或闭包），因此不会受到影响。但是，它引入了两个新的上下文关键字：<code>async</code>和<code>await</code>。</p>
<p>语法中<code>async</code>的用法位置（函数声明、函数类型和作为<code>let</code>的前缀）允许我们将async作为上下文关键字处理，而不会破坏源代码的兼容性。用户定义的<code>async</code>不能出现在代码的相应语法位置中。</p>
<p><code>await</code> 这个上下文相关的关键字有一些问题，因为它发生在表达式中。例如，我们可以在Swift中定义一个功能：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">await</span><span class="params">(<span class="number">_</span> x: Int, <span class="number">_</span> y: Int)</span></span> -&gt; <span class="type">Int</span> &#123; x + y &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = await(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这是一段格式良好的代码，它是对<code>await</code>函数的调用。根据这个提议，这段代码变成了一个带有子表达式(1,2)的<code>await</code>表达式，这对于现有的Swift程序来说是一个编译时错误，因为等待只能在异步上下文中使用，而且现有的Swift程序没有这样的上下文。这样的函数看起来并不常见，所以我们认为这是引入<code>async/await</code>时可以接受的源码破坏。</p>
<h2 id="对ABI稳定性的影响"><a href="#对ABI稳定性的影响" class="headerlink" title="对ABI稳定性的影响"></a>对ABI稳定性的影响</h2><p>无</p>
<h2 id="对API弹性的影响"><a href="#对API弹性的影响" class="headerlink" title="对API弹性的影响"></a>对API弹性的影响</h2><p>无</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/07/swiftconcurrencyroadmap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/07/swiftconcurrencyroadmap/" itemprop="url">Swift并发路线图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-07T17:42:57+08:00">
                2020-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文是<a href="https://github.com/airspeedswift/swift/blob/concurrency-roadmap/docs/ConcurrencyRoadmap.md" target="_blank" rel="noopener">SwiftConcurrencyRoadmap</a>的中文翻译</p>
</blockquote>
<p>我们的目标是使Swift在并发编程方面方便、高效和安全。</p>
<p>本文概述了对语言的一些添加和更改来实现<strong>asynchronous functions</strong>和<strong>actor</strong>的特性。这些提议将被分别提出，但在许多情况下它们将相互依赖。此文档用于对它们进行统一。宣言可能描述多个可能的方向，与此不同，本文描述了处理Swift并发性的单一计划。</p>
<p>这些即将产生的变化将会带来的是：</p>
<ul>
<li>异步编程更方便和清晰</li>
<li>提供一套标准的工具和技术，让swift开发者能够获得指引</li>
<li>优化编译期处理以提升异步代码的性能</li>
<li>以和消除内存不安全性同样的方式消除竞态条件和死锁</li>
</ul>
<p>这些特性的引入将跨越多个Swift版本。功能的引入大致分为两个阶段。第一个阶段引入异步语法和actor类型；这将允许用户以一种减少(而不是消除)数据竞争的方式来组织Actor的代码。第二阶段将强制执行完整的<code>Actor Isolation</code>，消除数据竞争，同时也将带来一些特性，实现高效和符合人体工程学的Actor交互操作，从而使隔离成为现实。</p>
<p>作为路线图，本文不像那些具体的proposal那样详细。本文还讨论了第二阶段的功能，但该阶段的详细建议将会在第一个阶段得到更好地定义之后再进行补充。</p>
<p>还有许多其他相关主题没有在本文档中介绍，比如异步流、并行for循环和分布式Actor。这些特性中的许多都是对路线图中所描述内容的补充，可以在任何时候引入。</p>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前，我们提倡的处理并发的基本模式是良好的：我们告诉大家应该使用队列而不是锁去保护状态，通过异步回调而不是阻塞的方式返回慢速操作的结果。</p>
<p>但是实际情况是我们可能会写出糟糕和容易出错的代码。看看下面的代码，你就会明白：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">(completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    refreshQueue.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.gameSession.allPlayers &#123; players <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.players = players.<span class="built_in">map</span>(\.nickname)</span><br><span class="line">            completion?()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有三点我们值得进行思考：</p>
<ul>
<li>我们写了非常多的<strong>公式代码</strong>，这个方法基本上只是进行一个简单调用，转换结果并赋值，但是处理线程和回调的代码太多了导致我们很难看清这个方法的本质</li>
<li>这些公式代码让<strong>产生bug变得更容易</strong>。我们在方法的回调中直接对<code>self.players</code>进行了赋值，那么这个赋值操作是在哪个线程上执行的呢？我们不清楚。所以这会带来潜在的数据竞争：回调可能需要被派发到正确的线程上执行。可能这个工作是<code>allPlayers</code>完成的，但我们无法根据现有的条件推断这段代码是否是线程安全的。</li>
<li>这段代码是低效的，尽管这是不必要的。首先，我们要分配几个方法对象的内存，对于像<code>self</code>这样的引用，我们必须拷贝到这些方法中，这带来了额外的引用计数的操作。这段代码可能会运行很多次，也可能根本不会运行，所以通常这使得编译器无法避免这些拷贝工作。</li>
</ul>
<p>此外，这些问题的耦合是不可避免的。异步回调一般来说总是准确地只运行一次，这意味着它们不会产生循环引用。由于Swift无法获知这一点，它要求<code>self</code>在闭包中显式地声明，所以一些程序员会条件反射地使用<code>[weak self]</code>。由于不得不处理<code>self</code>为空的情况，运行时开销和公式代码的增加也将无法避免。通常，当<code>self</code>为空时，这些方法会立即返回，这使得我们很难判断代码的正确性，因为任意量的代码可能会被跳过。</p>
<p>所以在这里基本模式没有问题，但是用swift进行表达会失去重要的结构信息并产生问题。解决方案是将这些基本模式引入到语言中。这将减少公式代码，并通过语言支持让基本模式更加安全，消除bug，并让程序员有信心更广泛地使用并发。也许它还将为我们提供一个提高并发代码性能的机会。</p>
<p>下面是使用我们提出的新语法重写的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">()</span></span> async &#123;</span><br><span class="line">  players = await gameSession.allPlayers().<span class="built_in">map</span>(\.nickname)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有几点值得注意：</p>
<ul>
<li><code>refreshPlayers</code>现在是<code>async</code>修饰的方法了</li>
<li><code>allPlayers</code>也是<code>async</code>修饰的方法，并且方法会返回结果而不是通过回调传递</li>
<li>我们可以使用表达式的组合去直接调用<code>map</code>方法</li>
<li><code>await</code>关键字表明<code>refreshPlayers</code>这个方法将会在这一刻被挂起</li>
<li><code>await</code>的表现与<code>try</code>类似，它只需要在表达式中出现一次就可以了</li>
<li>显式声明的<code>self.</code>被消除了，因为已经没有闭包对<code>self</code>进行捕获了</li>
<li><code>allPlayers</code>和<code>players</code>的访问不再会有数据竞争的情况了</li>
</ul>
<p>为了理解最后一点是如何实现的，我们必须走出来看看队列应该如何使用来保护状态。</p>
<p>原始代码是一个使用<code>refreshQueue</code>保护其内部状态:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerRefreshController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">var</span> gameSession: <span class="type">GameSession</span></span><br><span class="line">  <span class="keyword">var</span> refreshQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"PlayerRefresh"</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">(completion: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)? = <span class="literal">nil</span>) &#123; </span><br><span class="line">    ... </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一种常见的模式：类具有私有队列和一些只能在队列上访问的属性。现在我们用一个<code>actor</code>来替换这种方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="class"><span class="keyword">class</span> <span class="title">PlayerRefreshController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">var</span> gameSession: <span class="type">GameSession</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">()</span></span> async &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会注意到：</p>
<ul>
<li>我们将这个类用<code>actor</code>进行修饰，这与给类一个私有队列并在队列里维护内部状态的做法是类似的</li>
<li>你还是需要使用队列来保护状态：编译器将确保类的方法在指定的队列上运行，并且它将阻止你在方法之外去访问这些状态。</li>
<li>因为编译器负责执行此操作，所以它可以更聪明地进行优化，比如当方法的调用是在不同的<code>actor</code>上的时候。</li>
</ul>
<p>上面我们展示了一个<code>actor</code>类，其中有一组经过严密封装的属性和代码。但我们现在的UI编程方式通常是将代码分散到大量的类中，而这些类本应在一个主线程中使用。所以主线程仍然是一种<code>actor</code>——我们称之为<strong>global actor</strong>。</p>
<p>您可以使用属性将类和方法绑定到<code>actor</code>上。编译器将允许您从任何地方引用这个类，但是要真正调用这个方法，您需要在<strong>UI Actor</strong>上进行调用。因此，如果<code>PlayerRefreshController</code>的所有动作都适合在全局UI <code>actor</code>上执行，我们将这样表示它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">UIActor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerRefreshController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> players: [<span class="type">String</span>] = []</span><br><span class="line">  <span class="keyword">var</span> gameSession: <span class="type">GameSession</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">refreshPlayers</span><span class="params">()</span></span> async &#123;  ...  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对于第一阶段的提议"><a href="#对于第一阶段的提议" class="headerlink" title="对于第一阶段的提议"></a>对于第一阶段的提议</h2><p>我们会在未来数周提出以下提议，以开展第一阶段的工作：</p>
<ul>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/async-await/proposals/nnnn-async-await.md" target="_blank" rel="noopener">async / await</a>，引入基于<a href="https://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">协程</a>的模型结构。方法可以声明为<code>async</code>，并且可以等待其他<code>async</code>方法的结果返回，这使得异步代码的单行表达成为可能。相关的<a href="https://forums.swift.org/t/concurrency-asynchronous-functions/41619" target="_blank" rel="noopener">讨论</a>。</li>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/structured-concurrency/proposals/nnnn-structured-concurrency.md" target="_blank" rel="noopener">TaskAPI and Structured Concurrency</a>，为标准库引入<code>task</code>的概念。api将提供包括<code>detached tasks</code>、用于动态创建<code>child tasks</code>的<code>task &quot;nurseries&quot;</code>，以及<code>task</code>的取消及优先级机制。它还将引入基于范围的机制来等待多个子<code>task</code>的返回值，机制设计的原则基于<a href="https://en.wikipedia.org/wiki/Structured_concurrency" target="_blank" rel="noopener">Structured concurrency</a>。相关的<a href="https://forums.swift.org/t/concurrency-structured-concurrency/41622" target="_blank" rel="noopener">讨论</a>。</li>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/actors/proposals/nnnn-actors.md" target="_blank" rel="noopener">Actors &amp; Actor Isolation</a>，这为并行编程提供了状态隔离，通过这种机制可以消除潜在的数据竞争。第一阶段的提议将引入部分<code>Actor Isolation</code>，将完全隔离留给下一阶段。相关的<a href="https://forums.swift.org/t/concurrency-actors-actor-isolation/41613" target="_blank" rel="noopener">讨论</a>。</li>
<li><a href="https://github.com/DougGregor/swift-evolution/blob/concurrency-objc/proposals/NNNN-concurrency-objc.md" target="_blank" rel="noopener">Concurrency Interoperability with Objective-C</a>，它将为swift的并行特性（比如<code>async</code>方法）和Objective-C的一些约定俗成的异步方法表达提供自动桥接。这将允许现有的异步Objective-C api在swift的并发模型中立即可用，做法是为swift的转换提供两个选择，一个是直接转换为<code>async</code>方法，另外一个向后兼容提供基于回调的版本。相关的<a href="https://forums.swift.org/t/concurrency-interoperability-with-objective-c/41616" target="_blank" rel="noopener">讨论</a>。</li>
<li><strong>Async handlers</strong>，它提供了声明同步的<code>actor</code>方法为一个异步处理的能力。这些方法的表现非常像一个同步方法，但是在内部，他们会被异步处理。这将允许一些传统的通知概念（比如<code>UITableViewDelegate</code>）去异步地执行而无需繁琐的设置。</li>
</ul>
<h2 id="Actor-Isolation以及第二阶段"><a href="#Actor-Isolation以及第二阶段" class="headerlink" title="Actor Isolation以及第二阶段"></a>Actor Isolation以及第二阶段</h2><p>我们的目标是在正常情况下防止可变状态上的数据竞争。实现此目的的系统称为<code>Actor Isolation</code>，这是因为<code>actor</code>是整套机制能够得以实现的核心概念，而且这套机制的重点将放在防止<code>actor</code>外部访问<code>actor</code>保护的状态。然而，在需要确保系统在并发状态下的正确性时，<code>Actor Isolation</code>机制同样会对代码做出限制，即使在<code>actor</code>没有直接参与的情况下。</p>
<p>我们打算分两个阶段介绍路线图中描述的特性：首先介绍创建异步方法和<code>actor</code>的能力；第二，实施完整的<code>Actor Isolation</code>。</p>
<p><code>Actor Isolation</code>的基本思想与<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0176-enforce-exclusive-access-to-memory.md" target="_blank" rel="noopener">独占访存</a>的思想类似，并以此为基础。Swift的并发设计旨在通过从<code>actor</code>的自然隔离开始，然后使用所有权作为补充工具，提供一种易于使用和可组合的安全并发方法。</p>
<p><code>Actor Isolation</code>问题将被简化为确保所有普通的可变内存仅由特定的<code>actor</code>或<code>task</code>访问的问题。这进而简化为如何访问内存以及谁可以优先访问的分析。我们可以把情况分成这样几类：</p>
<ul>
<li><code>actor</code>的属性将会被被<code>actor</code>所保护</li>
<li>不可变内存（比如<code>let</code>变量）、局部内存（比如完全不会被被捕获的本地变量），以及值类型内存（比如结构体的属性或者枚举），将会被保护，不会产生数据竞争</li>
<li>不安全的内存（如<code>UnsafeMutablePointer</code>引用的任意内存）与不安全的抽象相关联。试图做到安全地使用这些抽象是不可取的，因为这些抽象的目的是在必要时可以用来绕过安全的语言规则。相反，我们寄希望于程序员会正确使用这些类型。</li>
<li>全局内存（如全局或静态变量）原则上可以被任何地方的代码访问，所以会出现数据竞争。</li>
<li>类相关的内存也可以从任何持有该类的引用的代码中访问。这意味着，虽然对类的引用可能受到<code>actor</code>的保护，但在<code>actor</code>之间传递该引用会使其属性暴露在数据竞争中。这也包括在值类型中持有的对类的引用，当这些引用在<code>actor</code>之间传递时。</li>
</ul>
<p>完整的<code>Actor Isolation</code>的目标是确保这最后两种情况受到保护。</p>
<h3 id="第一阶段：基本的Actor-Isolation"><a href="#第一阶段：基本的Actor-Isolation" class="headerlink" title="第一阶段：基本的Actor Isolation"></a>第一阶段：基本的<code>Actor Isolation</code></h3><p>第一阶段带来了安全性上的好处。人们将能够用全局<code>actor</code>保护全局变量，并通过将其转换为<code>actor</code>类来保护类成员。需要在特定队列上进行访问的框架可以定义一个全局行为体，并为其提供默认协议。</p>
<p>在这一阶段，一些重要的<code>Actor Isolation</code>将被强制执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> immutable: <span class="type">String</span> = <span class="string">"42"</span></span><br><span class="line">  <span class="keyword">var</span> mutableArray: [<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">synchronousFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mutableArray += [<span class="string">"syncFunction called"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyActor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">asyncFunction</span><span class="params">(other: MyActor)</span></span> async &#123;</span><br><span class="line">    <span class="comment">// allowed: an actor can access its internal state, even in an extension</span></span><br><span class="line">    <span class="keyword">self</span>.mutableArray += [<span class="string">"asyncFunction called"</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// allowed: immutable memory can be accessed from outside the actor</span></span><br><span class="line">    <span class="built_in">print</span>(other.immutable)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: an actor cannot access another's mutable state</span></span><br><span class="line">    otherActor.mutableArray += [<span class="string">"not allowed"</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// error: either reading or writing</span></span><br><span class="line">    <span class="built_in">print</span>(other.mutableArray.first)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allowed: async functions can call async functions on other actors</span></span><br><span class="line">    await other.asyncFunction(otherActor: <span class="keyword">self</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error: only asynchronous functions can be called from outside the actor</span></span><br><span class="line">    other.synchronousFunction()    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些改变不会对现有的swift代码带来改变，因为<code>actor</code>和<code>async</code>是一个新特性。</p>
<h3 id="第二阶段：完整的Actor-Isolation"><a href="#第二阶段：完整的Actor-Isolation" class="headerlink" title="第二阶段：完整的Actor Isolation"></a>第二阶段：完整的<code>Actor Isolation</code></h3><p>即使在引入<code>actor</code>之后，全局变量和引用类型的值，仍然存在数据竞争的可能性：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> racyGlobal: [<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line">@<span class="type">MyGlobalActor</span></span><br><span class="line"><span class="keyword">var</span> safeGlobal: [<span class="type">String</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlainOldClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> unprotectedState: <span class="type">String</span> = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor <span class="class"><span class="keyword">class</span> <span class="title">RacyActor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> immutableClassReference: <span class="type">PlainOldClass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">racyFunction</span><span class="params">(other: RacyActor)</span></span> async &#123;</span><br><span class="line">    <span class="comment">// protected: global variable protected by a global actor</span></span><br><span class="line">    safeGlobal += [<span class="string">"Safe access"</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// unprotected: global variable not in an actor</span></span><br><span class="line">    racyGlobal += [<span class="string">"Racy access"</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// unprotected: racyProperty is immutable, but it is a reference type</span></span><br><span class="line">    <span class="comment">// so it allows access to unprotected shared mutable type</span></span><br><span class="line">    other.takeClass(immutableClassReference)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">takeClass</span><span class="params">(<span class="number">_</span> plainClass: PlainOldClass)</span></span> &#123;</span><br><span class="line">    plainClass.unprotectedState += [<span class="string">"Racy access"</span>]  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在第一阶段，我们打算保留Swift目前的行为：全局变量和引用类型的内存不会受到保护。因此<code>actor</code>对于它们来说也不是安全的。因为这是swift目前的行为，所以这也不会对现有的swift代码带来改变。</p>
<p>在第二阶段，我们将引入一套工具链来处理完整的<code>Actor Isolation</code>。其中最重要的一点是将一个类型限制为<code>local actor</code>。当一个类型被标记为<code>local actor</code>时，编译器将阻止它在<code>actor</code>之间传递。引用需要通过某种方式进行拷贝或者以非共享的方式进行跨域传递。</p>
<p>这反过来又会对默认情况作出改变：</p>
<ul>
<li>全局变量将被要求由一个<code>global actor</code>保护，或标记为 <code>unsafe actor</code>。</li>
<li>类（和包含类引用的类型）将从默认的 <code>unsafe actor</code>变为<code>local actor</code>。</li>
</ul>
<p>这种改变将需要现有的Swift代码能够进行兼容，并且需要通过语言层来把关。触及可变的全局变量或跨<code>actor</code>边界共享的类引用，从根本上无法证明其不受数据竞争的影响，将需要改变以确保其免受数据竞争的影响（通过未来的代码）。希望这个兼容不会很繁琐：</p>
<ul>
<li>我们预期全局变量的使用应该是克制的，而且大多数全局变量可以由<code>global actor</code>保护;</li>
<li>只要类没有跨<code>actor</code>边界进行共享，<code>local actor</code>就不应该影响<code>actor</code>内部的代码;</li>
<li>在必须跨边界传递引用的地方，语言应该让这一点显现出来，解决方案也应该简单;</li>
<li>通过进一步鼓励和简化值类型的使用，跨边界共享的需求将会减少;</li>
<li>这两个阶段之间的时间将使用户有机会将他们的代码分解为<code>actor</code>和<code>async</code>方法，为完全隔离做好准备。</li>
</ul>
<p>与第一阶段的讨论不同，第二阶段需要的语言特性将首先在swift论坛的演化讨论版提出讨论。采取两个阶段的主要驱动因素之一是希望在转移到完全隔离模型之前给swift用户以时间来适应<code>async</code>方法和<code>actor</code>。将代码移植到<code>actor</code>和<code>async</code>方法的经验将告诉我们执行完全<code>Actor Isolation</code>所需的功能。这个反馈应该会反哺第二阶段的特性讨论。</p>
<p>预计将在第二阶段讨论的功能包括：</p>
<ul>
<li>引入<code>actorlocal</code>的限制类型</li>
<li>通过<code>mutableIfUnique</code>类类型，编译器能正确处理“写入拷贝”类型;</li>
<li>属性可选择退出<code>Actor Isolation</code>，例如通过其他方法处理线程安全的情况。</li>
</ul>
<h2 id="基本概念表"><a href="#基本概念表" class="headerlink" title="基本概念表"></a>基本概念表</h2><p>这些是将在整个设计中使用的基本概念，在这里简要定义：</p>
<ul>
<li><strong>synchronous function</strong>是Swift程序员已经习以为常的同步方法：它在一个线程上运行到完成，除了它调用的任何同步方法外，没有交叉代码。</li>
<li><strong>thread</strong>是指底层硬件的线程概念。平台各不相同，但往往具有相同的基本特征：真正的并发性需要创建线程，但创建和运行线程的成本很高。C方法调用和普通的同步Swift方法，都需要使用一个线程。</li>
<li><strong>asynchronous function</strong>是一种新的方法，它不需要运行到完成一路畅通。中断会导致方法被挂起。挂起点是指异步方法中断其线程的点。</li>
<li><strong>task</strong>是异步运行的操作。所有异步方法都作为某个任务的一部分运行。当一个异步方法调用另一个异步方法时，该调用仍然是同一任务的一部分，即使该调用必须更改<code>actor</code>。任务类似于异步方法的线程。</li>
<li>异步方法可以创建<strong>child task</strong>。子任务继承父任务的一些结构，包括其优先级，但可以与父任务并发运行。但是，这种并发性是有限制的：创建子任务的方法必须等待子任务结束后才能返回。</li>
<li>一个程序希望能开启独立的并发工作通过使用<strong>detached task</strong>，而不是一个有边界的child task来超越上下文边界。</li>
<li><strong>partial task</strong>是可调度的工作单元。task中当前执行的方法被挂起时，就是部分任务的结束，并创建一个新的partial task来继续整个task的工作。</li>
<li><strong>executor</strong>是一种服务，它接受partial task的提交，并安排某个线程运行它们。当前运行的异步方法总是知道它在哪个executor上运行。如果提交给执行程序的部分task永远不会并发运行，则称为<strong>exclusive executor</strong>。</li>
<li><strong>actor</strong>是程序中可以运行代码的独立部分。它一次只能运行一段代码—也就是说，它充当exclusive executor—但是它运行的代码可以与其他<code>actor</code>运行的代码并发执行。</li>
<li>一个actor的状态会受到保护，只有该actor才能访问。实现这一点所需的系统称为<strong>actor isolation</strong>。Swift的长期目标是在默认情况下保证actor isolation。</li>
<li><strong>actor class</strong>是一个引用类型，它的每个实例都是一个单独的actor。它的受保护状态是它的实例属性，它的actor方法是它的实例方法。</li>
<li><strong>global actor</strong>是全局对象。它的受保护状态和actor方法可以分布在许多不同的类型中。它们可以标记为一个特定于actor的属性，在许多情况下Swift可以推断出这个属性。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/01/Why-heic-lost-rotation/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/01/Why-heic-lost-rotation/" itemprop="url">Why heic lost rotation?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-01T21:53:08+08:00">
                2020-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的项目中支持了heic的上传和展示。在iOS 14之前，一切都很美好，我们享受着heic带来的图片体积的减小。但是在iOS 14以及新的macOS中，事情发生了变化，非常多的heic图片的展示方向都和预想的不一样。这是怎么回事呢？</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的项目中在图片上传之前会对图片本身进行一些ImageI/O相关的处理。</p>
<p>首先，我们会将图片downsampling，对于图片的像素数量我们有一个最大的限制是15000000个像素。对于图片最短边的尺寸我们限制为1500个像素。也就是说，假设原图大小是3000<em>4000，我们会把图片缩放到1500</em>2000。实现原理是通过<em>WWDC18 session 219</em>介绍的方式，通过ImageI/O进行处理（详情见<a href="https://junjielu.github.io/2020/08/27/%E5%9B%BE%E7%89%87%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">图片渲染优化</a>）。</p>
<p>downsampling完成之后，我们会根据图片的类型进行compress。比如对于jpeg以及heic，我们会进行一个0.75 compress quality的压缩（经验值）。</p>
<h2 id="问题出在哪？"><a href="#问题出在哪？" class="headerlink" title="问题出在哪？"></a>问题出在哪？</h2><p>首先拿到heic原图和经过我们处理后的图片，通过<code>exiftool</code>打印图片的元信息，这里仅对相关的属性进行一个diff（左边是原图，右边是处理过的图片）：</p>
<p><img src="diff.png" alt=""></p>
<p>我们发现这个<code>Rotation</code>信息和之前的不一样了，于是我们合理怀疑一下是不是这个<code>Rotation</code>导致图片展示方向出了问题？</p>
<p>然而根据我们之前的经验和相关的苹果的文档，图片的方向是根据<code>Orientation</code>来进行计算的，而两边图片元信息中的<code>Orientation</code>的值都是一样的：<code>Rotate 90 CW</code>即顺时针旋转90度。这又是为什么呢？</p>
<p>后来我们得知，这个<code>Rotation</code>是heic独有的属性，因此我们推测，在新的系统上，苹果使用了这个<code>Rotation</code>来进行图片方向的判断。</p>
<h2 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h2><p>Fine，那为什么经过我们处理后的图片会丢失<code>Rotation</code>相关的信息呢？经过了几天各种各样乱七八糟的尝试以及各地各式的资料搜集，我们依旧没能找到答案，这个<code>Rotation</code>信息就这么没了。。。</p>
<p>于是我们作出了一个假设就是ImageI/O的处理就是会导致失去<code>Rotation</code>信息，那么我们解决的思路就分以下两种：</p>
<ul>
<li>不遗余力把这个<code>Rotation</code>信息找回来</li>
<li>在downsampling的时候让ImageI/O把图片先转一下</li>
</ul>
<p>第二个方案实现起来很简单，只需要在downsampling的时候把<code>kCGImageSourceCreateThumbnailWithTransform</code>设为true就好了，但是我们又会发现，转过来了之后在旧的iOS版本上，图片方向又是错的了，原因可能是在旧版本上系统是根据<code>Orientation</code>来判断图片方向的。。。</p>
<p>所以到目前为止，我们唯一稍微可行的方案是：在downsampling的时候把图片先转一下，在encode的阶段把meta data全丢掉，这样显示的就是对的，可这么做似乎并不优雅。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在一筹莫展之际，我随意地翻了翻ImageI/O相关的接口和注释，发现一个有趣的东西：<code>kCGImageDestinationImageMaxPixelSize</code>，这是一个在encode的时候的一个配置项，但是和downsampling的一个配置项非常像：<code>kCGImageSourceThumbnailMaxPixelSize</code>。</p>
<p>于是我有了一个大胆的假设，是不是真正的最佳实践并不是手动downsampling+encode，而是通过encode的配置项实现downsampling，反正图片编码也会进行downsampling。</p>
<p>于是我动手改造原来的代码，将手动downsampling的过程去掉，通过<code>CGImageDestinationAddImageFromSource</code>的方法传入图片的image source进行encode，而不是之前直接传入<code>CGImage</code>。果然，经过处理后的图片没有丢掉<code>Rotation</code>，我们得到了一个可能是完美的解决方案。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ImageI/O相关的文档和注释真的非常之少，而且缺乏系统指导性的最佳实践，甚至连苹果系统内部对于图片方向的判断逻辑都出现严重的前后不一。不过通过这个问题，我们推想出了一个最佳实践，那就是只有在显示渲染的时候，我们才去做手动downsampling，对于encode来说，downsampling的操作是可以传入参数自动完成的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/27/Debug Universal Link/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/27/Debug Universal Link/" itemprop="url">Debug Universal Link</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-27T22:37:03+08:00">
                2020-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这片文章主要是记录一下几个月前发生的一件事，其中有些经验值得写一写。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>有一次我们的测试给我提了一个bug是说App间的跳转不生效了。我们的App是通过Universal Link进行跳转的，所以我第一时间先在我的手机检查了一下 Safari 的跳转和 <code>apple-app-site-association</code> 文件内容，发现都没有问题。当时就很困惑到底哪里出了问题，所以去社区看了看有没有类似的问题，发现了两个radar:</p>
<ul>
<li><a href="https://openradar.appspot.com/45201697" target="_blank" rel="noopener">rdar://45201697: iOS 12 cannot fetch AASA file within 5 minutes after rebooting the phone</a></li>
<li><a href="https://openradar.appspot.com/33893852" target="_blank" rel="noopener">rdar://33893852: Certain users fail to download apple-app-site-association when downloading the app</a></li>
</ul>
<p>看了一下基本都是下载 AASA 的问题，那问题来了，下载 AASA 文件的过程要怎么debug呢？</p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>看了一下网上的方案，大致上分为两种：</p>
<h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><p>根据这个讨论 <a href="https://discussions.apple.com/thread/250111811#:~:text=swcd%20is%20the%20shared%20web,When%20swcd" target="_blank" rel="noopener">what is SWC Agent Database in keychain?</a> 我们可以了解到 AASA 文件的下载是在 swcd 这个进程进行的。所以我们可以打开 Console，用手机重新安装App，选择查看 swcd 的log来进行debug。</p>
<p>我尝试了这种方法，发现问题是出在测试的手机上有代理，导致 AASA 下载失败了。</p>
<p>然而，后来我发现还有一种更神秘的方案可以进行debug。</p>
<h3 id="Sysdiagnose"><a href="#Sysdiagnose" class="headerlink" title="Sysdiagnose"></a>Sysdiagnose</h3><p>苹果的工程师在去年曾经介绍了一种 debug universal link 的方式：<a href="https://twitter.com/grynspan/status/1136294209328041993" target="_blank" rel="noopener">Twitter</a>。结合 Sysdiagnose ，日志收集流程如下：</p>
<ol>
<li>复现问题</li>
<li>同时按下两个音量键和侧边键1秒左右，如果成功触发 Sysdiagnose，你会感受到一个震动</li>
<li>等待10分钟</li>
<li>在手机的log中找到 <code>sysdiagnose_YYYY.MM.DD_HH-MM-SS-XX…</code> 这样匹配你的时间的文件并发到你的设备上</li>
<li>打开其中的 <code>swcutil_show.txt</code> 你就能看到非常详细的 universal link 信息。</li>
</ol>
<p><img src="644ADED7-A50E-4BBF-99F4-D7AF976EBC20.png" alt=""></p>
<p>好吧，真的是非常详细了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了一些很tricky的东西。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/27/图片渲染优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/27/图片渲染优化/" itemprop="url">图片渲染优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-27T01:21:01+08:00">
                2020-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>图片渲染是iOS app中必不可少的一环，当我们在屏幕上展示一幅图片的时候，一个 workflow 应该是这样的：</p>
<ul>
<li>拿到图片的 Data buffer</li>
<li>decode 得到图片的 Image buffer</li>
<li>将 Image buffer 渲染到屏幕上</li>
</ul>
<p>这个流程看上去没有问题，但是有一点值得我们注意。假设我们要显示一张 2000 <em> 1000 的图片，在decode环节我们decode出来的 image buffer 的大小就会是 2000 </em> 1000 <em> 4 byte = 7.6MB，这里我们会发现 image buffer 的大小和图片的分辨率是正相关的，但有的时候，图片和最终展示在界面上的尺寸是不同的。比如这张 2000 </em> 1000 的图片，假如是展示在一个 200 * 100 的 view 上，那显然有很多像素信息是会被浪费掉的。</p>
<p>如何解决这个问题呢？</p>
<h2 id="Downsampling"><a href="#Downsampling" class="headerlink" title="Downsampling"></a>Downsampling</h2><p>我们的思路可能是说建立一个新的 workflow ：</p>
<ul>
<li>拿到图片的 Data buffer</li>
<li>根据显示区域的大小建立一个 thumbnail 区域</li>
<li>decode 图片的 Data buffer 到这个 thumbnail 区域，得到一个小一些的 Image buffer</li>
<li>将 Image buffer 渲染到屏幕上</li>
</ul>
<p>WWDC18-session219 详细介绍了如何去进行这样的 downsampling，同事值得注意的是我们可以将 downsampling 的过程放在后台线程进行，再将结果回调到主线程进行展示，这也很大程度上能缓解 CPU 的压力。</p>
<p><img src="219_hd_image_and_graphics_best_practices-0001.png" alt=""></p>
<h2 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h2><p>别误会，这里的 rasterization 并不是 <code>CALayer</code> 的概念。我们在图片渲染上头疼的点在于图片像素尺寸和界面上展示的尺寸很可能是不同的。这里其实我们还会想到一种方案来解决：使用矢量图。</p>
<p>矢量图和位图不同，矢量图并不存储图片的像素信息，它是通过数学表达的方式通过点和曲线的连接来构成图形。图形层显示矢量图会进行 rasterization 来将矢量图信息转换成位图的信息并直接渲染到 frame buffer 上。</p>
<p>在 iOS 13 以前，我们使用矢量图的方案是通过在 image assets 添加PDF文件来实现。Xcode 会在编译期来进行 rasterization 将图片转换成位图（当然这样做也失去了矢量图的一些特性）。</p>
<p>在 iOS 13之后，我们可以通过私有库 <code>CoreSVG</code> 进行 SVG 的渲染，在未来，我们也有希望使用 <a href="https://svgwg.org/specs/svg-native/" target="_blank" rel="noopener">SVG Native</a> 来进行规范化的矢量图形渲染。</p>
<h2 id="Rendering-Speed"><a href="#Rendering-Speed" class="headerlink" title="Rendering Speed"></a>Rendering Speed</h2><p>通过上面的做法，我们基本已经避免了在渲染层面上浪费过多的内存的情况，那么我们如何再进一步去优化渲染速度呢？</p>
<p>从 iOS 10 开始， <code>UICollectionView</code> 就支持了通过 <a href="https://developer.apple.com/documentation/uikit/uicollectionviewdatasourceprefetching" target="_blank" rel="noopener">UICollectionViewDataSourcePrefetching</a> 来通过预加载来异步获取数据的方案。我们可以通过预加载来提前在后台线程执行图片的获取和解码，在用户视角上提高渲染的速度。</p>
<p>还有一种方案也是通过提前解码来实现加速渲染的，那就是很多第三方库所使用的预解码技术。</p>
<p>在这之前我们先了解一下 <code>Core Animation</code> 的渲染原理。</p>
<p><img src="1*IVE7oJ666BYq8RtLq-Vs4Q.png" alt=""></p>
<p>用人话来说就是对于 <code>UIImageView</code> 来说，渲染流程是这样的：</p>
<ul>
<li>拿到 <code>UIImageView</code> 的 <code>layer.contents</code></li>
<li>从拿到的 <code>CGimage</code> decode 获取 image buffer</li>
<li>向GPU发送 Draw Calls</li>
<li>GPU进行渲染然后将结果展示在硬件上</li>
</ul>
<p>那么我们的优化方向就是如何让 render server 提前拿到 image buffer，这样就能加快渲染速度了。这里我们就要说说 <code>CGImage</code> 这个东西了。</p>
<h3 id="CGImage"><a href="#CGImage" class="headerlink" title="CGImage"></a>CGImage</h3><p>我们先看看 <code>CGImage</code> 的初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>?(width: <span class="type">Int</span>, </span><br><span class="line">height: <span class="type">Int</span>, </span><br><span class="line">bitsPerComponent: <span class="type">Int</span>, </span><br><span class="line">bitsPerPixel: <span class="type">Int</span>, </span><br><span class="line">bytesPerRow: <span class="type">Int</span>, </span><br><span class="line">space: <span class="type">CGColorSpace</span>, </span><br><span class="line">bitmapInfo: <span class="type">CGBitmapInfo</span>, </span><br><span class="line">provider: <span class="type">CGDataProvider</span>, </span><br><span class="line">decode: <span class="type">UnsafePointer</span>&lt;<span class="type">CGFloat</span>&gt;?, </span><br><span class="line">shouldInterpolate: <span class="type">Bool</span>, </span><br><span class="line">intent: <span class="type">CGColorRenderingIntent</span>)</span><br></pre></td></tr></table></figure>
<p>值得注意的是这个 provider，就是通过它来生成渲染所需要的 image buffer。经过研究，发现这里创建出 <code>CGImage</code> 但并没有进行 decode，而是在需要显示渲染的时候通过调用 <code>CGDataProviderCopyData</code> 来触发decode。所以我们这时列一下整个解码流程：</p>
<ul>
<li>获取 <code>layer.contents</code></li>
<li>获取 <code>image.cgImage</code></li>
<li><code>CGImageGetDataProvider</code> 获取data</li>
<li><code>CGDataProviderRetainBytePtr</code> 触发解码</li>
<li><code>CGDataProviderDirectCallbacks</code> 拿到数据</li>
<li>ImageIO进行解码拿到 image buffer</li>
</ul>
<p>了解了整个流程我们就知道了 iOS 系统的方案在生成 <code>CGImage</code> 的时候并没有创建完整的 image buffer ，而是在渲染的时候进行处理。那我们优化的方向就是用空间换时间，如果能在生成 <code>CGImage</code> 生成的时候直接把 image buffer 创建好，那渲染就会快很多了。</p>
<p>主流图片库的做法也很简单，通过<code>CGContextDrawImage</code> 绘制一遍生成出来的 <code>CGImage</code> 就可以了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲述了三种图片渲染上优化的方向，希望可以和对图片渲染有兴趣的朋友多多交流。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/30/Haskell/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junjie Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ballad">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/30/Haskell/" itemprop="url">Haskell</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-30T10:57:01+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://www.cis.upenn.edu/~cis194/spring13/images/haskell-logo-small.png" alt="Haskell"></p>
<blockquote>
<p>Haskell is a <em>lazy, functional</em> programming language created in the late 1980’s by a committee of academics. </p>
</blockquote>
<ul>
<li><strong>functional</strong>: functions are <em>first-class</em>, centered around <em>evaluating expressions</em> rather than <em>executing instructions</em>.</li>
<li><strong>pure</strong>: <em>immutable</em>, no <em>side effects</em>, calling the same function with the same arguments results in the same output every time.</li>
<li><strong>lazy</strong>: <em>call-by-need</em>, expressions are <em>not evaluated until their results are actually needed</em>.Alone with <em>Memoization</em></li>
<li><strong>statically typed</strong>: as Swift.Every Haskell expression has a type, and types are all checked at <em>compile-time</em>.</li>
<li><strong>abstraction</strong>: <em>parametric polymorphism</em>, <em>higher-order functions</em></li>
<li><strong>wholemeal programming</strong>: </li>
</ul>
<blockquote>
<p>“Functional languages excel at wholemeal programming, a term coined by Geraint Jones. Wholemeal programming means to think big: work with an entire list, rather than a sequence of elements; develop a solution space, rather than an individual solution; imagine a graph, rather than a single path. The wholemeal approach often offers new insights or provides new perspectives on a given problem. It is nicely complemented by the idea of projective programming: first solve a more general problem, then extract the interesting bits and pieces by transforming the general program into more specialised ones.” — Ralf Hinze</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; int acc = 0;</span><br><span class="line">for ( int i = 0; i &lt; lst.length; i++ ) &#123;</span><br><span class="line">  acc = acc + 3 * lst[i];</span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>to</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sum (map (3*) lst)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Lazy-evaluation"><a href="#Lazy-evaluation" class="headerlink" title="Lazy evaluation"></a>Lazy evaluation</h2><h4 id="Strict-evaluation"><a href="#Strict-evaluation" class="headerlink" title="Strict evaluation"></a>Strict evaluation</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f (release_monkeys(), increment_counter())</span><br></pre></td></tr></table></figure>
<p>If the releasing of monkeys and incrementing of the counter could independently happen, or not, in either order, depending on whether f happens to use their results, it would be extremely confusing. When such <em>“side effects”</em> are allowed, strict evaluation is really what you want.</p>
<h4 id="Side-effects-and-purity"><a href="#Side-effects-and-purity" class="headerlink" title="Side effects and purity"></a>Side effects and purity</h4><p>By “side effect” we mean anything that <em>causes evaluation of an expression to interact with something outside itself</em>.The root issue is that such outside interactions are time-sensitive.</p>
<ul>
<li>No global variable</li>
<li>No output to screen</li>
<li>No reading from a file or the network</li>
</ul>
<p>WTF……</p>
<p>The solution is IO monad.</p>
<h4 id="Consequences"><a href="#Consequences" class="headerlink" title="Consequences"></a>Consequences</h4><ul>
<li>Purity</li>
<li>Tricky space usage</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- Standard library function foldl, provided for reference</span><br><span class="line">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line">foldl _ z []     = z</span><br><span class="line">foldl f z (x:xs) = foldl f (f z x) xs</span><br><span class="line"></span><br><span class="line">foldl (+) 0 [1,2,3]</span><br><span class="line">= foldl (+) (0+1) [2,3]</span><br><span class="line">= foldl (+) ((0+1)+2) [3]</span><br><span class="line">= foldl (+) (((0+1)+2)+3) []</span><br><span class="line">= (((0+1)+2)+3)</span><br><span class="line">= ((1+2)+3)</span><br><span class="line">= (3+3)</span><br><span class="line">= 6</span><br><span class="line"></span><br><span class="line">foldl&apos; (+) 0 [1,2,3]</span><br><span class="line">= foldl&apos; (+) (0+1) [2,3]</span><br><span class="line">= foldl&apos; (+) 1 [2,3]</span><br><span class="line">= foldl&apos; (+) (1+2) [3]</span><br><span class="line">= foldl&apos; (+) 3 [3]</span><br><span class="line">= foldl&apos; (+) (3+3) []</span><br><span class="line">= foldl&apos; (+) 6 []</span><br><span class="line">= 6</span><br></pre></td></tr></table></figure>
<p>Consider if there is a very long list, it leads to stack overflow.</p>
<ul>
<li>Short-circuiting operators</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span><br><span class="line">True  &amp;&amp; x = x</span><br><span class="line">False &amp;&amp; _ = False</span><br></pre></td></tr></table></figure>
<ul>
<li>Infinite data structures</li>
<li>Pipelining/wholemeal programming<ul>
<li>due to laziness, each stage of the pipeline can operate in lockstep, only generating each bit of the result as it is demanded by the next stage in the pipeline.</li>
</ul>
</li>
<li>Thunk.</li>
<li>Confilct with parallel computing.</li>
</ul>
<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><ul>
<li>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</li>
<li>treeMap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b</li>
<li>maybeMap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</li>
</ul>
<p>why not</p>
<p><code>thingMap :: (a -&gt; b) -&gt; f a -&gt; f b</code></p>
<p>Since f is type variable, we can make a type class, which is traditionally called <strong>Functor</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Functor f where</span><br><span class="line">  fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">  </span><br><span class="line">(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br><span class="line">  </span><br><span class="line">instance Functor [] where</span><br><span class="line">  fmap _ []     = []</span><br><span class="line">  fmap f (x:xs) = f x : fmap f xs</span><br><span class="line">  </span><br><span class="line">instance Functor Maybe where</span><br><span class="line">  fmap _ Nothing  = Nothing</span><br><span class="line">  fmap h (Just a) = Just (h a)</span><br></pre></td></tr></table></figure>
<h2 id="Applicative-functors"><a href="#Applicative-functors" class="headerlink" title="Applicative functors"></a>Applicative functors</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name = String</span><br><span class="line"></span><br><span class="line">data Employee = Employee &#123; name    :: Name</span><br><span class="line">                         , phone   :: String &#125;</span><br></pre></td></tr></table></figure>
<p>So Employee is </p>
<p><code>Employee :: Name -&gt; String -&gt; Employee</code></p>
<p>However, sometimes we want this:</p>
<p><code>(Name -&gt; String -&gt; Employee) -&gt; Maybe Name -&gt; Maybe String -&gt; Maybe Employee</code></p>
<p>and why not provide this as well:</p>
<p><code>Name -&gt; String -&gt; Employee) -&gt; [Name] -&gt; [String] -&gt; [Employee]</code></p>
<p>Seems wec can use <code>fmap</code> to do this job, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Functor f where</span><br><span class="line">  fmap2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">  </span><br><span class="line">fmap2 :: Functor f =&gt; (a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</span><br><span class="line">fmap2 h fa fb = ???</span><br><span class="line"></span><br><span class="line">h :: a -&gt; (b -&gt; c)</span><br><span class="line">fmap h :: fa -&gt; f(b -&gt; c)</span><br><span class="line">fmap h fa :: f(b -&gt; c)</span><br></pre></td></tr></table></figure>
<p>The reason why we cannot implement fmap2 is <code>fmap h fa :: f (b -&gt; c)</code>, and we cannot handle <code>f (b -&gt; c)</code> with <code>f b</code></p>
<p>So it’s time to introduce <em>Applicative</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Functor f =&gt; Applicative f where</span><br><span class="line">  pure  :: a -&gt; f a</span><br><span class="line">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line">liftA2 h fa fb = (h `fmap` fa) &lt;*&gt; fb</span><br><span class="line"></span><br><span class="line">liftA3 :: Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d</span><br><span class="line">liftA3 h fa fb fc = ((h &lt;$&gt; fa) &lt;*&gt; fb) &lt;*&gt; fc</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Law for <code>Applicative</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; f `fmap` x === pure f &lt;*&gt; x</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h2><p>From <em>functor</em> and <em>applicative</em>, we can see computations with a fixed structure.</p>
<p>However, sometimes we want to be able to decide what to do based on some intermediate results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtype Parser a = Parser &#123; runParser :: String -&gt; Maybe (a, String) &#125;</span><br></pre></td></tr></table></figure>
<p>Suppose we are trying to parse a file containing a sequence of numbers, like this:</p>
<blockquote>
<p>4 78 19 3 44 3 1 7 5 2 3 2</p>
</blockquote>
<p>So the example above could be broken up into groups like this:</p>
<blockquote>
<p>78 19 3 44   – first group<br>1 7 5        – second group<br>3 2          – third group</p>
</blockquote>
<p>So what we need is some thing like this:<br><code>parseFile :: Parser [[Int]]</code> </p>
<p><em>Applicative</em> gives us no way to decide what to do next based on previous results: we must decide in advance what parsing operations we are going to run, before we see the results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Monad m where</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line"></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line"></span><br><span class="line">  (&gt;&gt;)  :: m a -&gt; m b -&gt; m b</span><br><span class="line">  m1 &gt;&gt; m2 = m1 &gt;&gt;= \_ -&gt; m2</span><br></pre></td></tr></table></figure>
<p><code>m</code> refer to <em>monads</em> and <code>m a</code> refer to <em>mobits</em>. A mobit of type <code>m</code> a represents a computation which results in a value (or several values, or no values) of type <code>a</code>.</p>
<p>A function which will choose the next computation to run based on the result(s) of the first computation.</p>
<p>So all (&gt;&gt;=) really does is put together two mobits to produce a larger one, which first runs one and then the other, returning the result of the second one. </p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p><a href="http://www.seas.upenn.edu/~cis194/spring13/lectures.html" target="_blank" rel="noopener">CIS 194</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Junjie Lu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/junjielu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/lujunjie1008" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junjie Lu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
